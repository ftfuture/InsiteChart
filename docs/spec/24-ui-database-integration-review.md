# UI ÏóòÎ¶¨Î®ºÌä∏ÏôÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≥Ñ Ï†ÑÏ≤¥ Ïû¨Í≤ÄÌÜ†

## 1. Í∞úÏöî

Ïù¥ Î¨∏ÏÑúÎäî UI ÏóòÎ¶¨Î®ºÌä∏ÏôÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏóòÎ¶¨Î®ºÌä∏ Í∞ÑÏùò Ïó∞Í≥ÑÎ•º Ï†ÑÏ≤¥Ï†ÅÏúºÎ°ú Ïû¨Í≤ÄÌÜ†Ìï©ÎãàÎã§. Í∏∞Ï°¥ Î∂ÑÏÑù Î¨∏ÏÑúÎì§ÏùÑ Ï¢ÖÌï©Ï†ÅÏúºÎ°ú Í≤ÄÌÜ†ÌïòÍ≥†, ÎàÑÎùΩÎêú Ïó∞Í≤∞Ï†êÏù¥ÎÇò Ï∂îÍ∞ÄÎ°ú Î≥¥ÏôÑÌï† ÏÇ¨Ìï≠ÏùÑ ÏãùÎ≥ÑÌïòÏó¨ ÏôÑÏ†ÑÌïú UI-Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Îèô ÏãúÏä§ÌÖúÏùÑ Íµ¨Ï∂ïÌïòÎäî Í≤ÉÏùÑ Î™©ÌëúÎ°ú Ìï©ÎãàÎã§.

### 1.1 Í≤ÄÌÜ† Î≤îÏúÑ

- **UI ÏóòÎ¶¨Î®ºÌä∏**: Í≤ÄÏÉâ, Ï∞®Ìä∏, ÏÑºÌã∞Î®ºÌä∏ Î∂ÑÏÑù, Í¥ÄÏã¨Ï¢ÖÎ™©, ÏïåÎ¶º Îì± Ï£ºÏöî UI Ïª¥Ìè¨ÎÑåÌä∏
- **Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏóòÎ¶¨Î®ºÌä∏**: ÌÖåÏù¥Î∏î, Ïù∏Îç±Ïä§, Ìä∏Î¶¨Í±∞, Ï†úÏïΩ Ï°∞Í±¥ Îì± Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Íµ¨ÏÑ± ÏöîÏÜå
- **Ïó∞Í≥Ñ Î©îÏª§ÎãàÏ¶ò**: API Ìò∏Ï∂ú, Îç∞Ïù¥ÌÑ∞ Î≥ÄÌôò, Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî, Ï∫êÏã± Ï†ÑÎûµ
- **ÏÑ±Îä• Í≥†Î†§ÏÇ¨Ìï≠**: ÏøºÎ¶¨ ÏµúÏ†ÅÌôî, Ïù∏Îç±Ïã±, Îç∞Ïù¥ÌÑ∞ ÏïïÏ∂ï, Î°úÎìú Î∞∏Îü∞Ïã±

### 1.2 Í≤ÄÌÜ† Î∞©Î≤ïÎ°†

1. **Í∏∞Ï°¥ Î¨∏ÏÑú Î∂ÑÏÑù**: UI/UX Î∂ÑÏÑù, ÏõåÌÅ¨ÌîåÎ°úÏö∞ Î∂ÑÏÑù, Îß§Ìïë Î∂ÑÏÑù Î¨∏ÏÑú Ï¢ÖÌï© Í≤ÄÌÜ†
2. **Îç∞Ïù¥ÌÑ∞ ÌùêÎ¶Ñ Ï∂îÏ†Å**: UI Ïù¥Î≤§Ìä∏Î∂ÄÌÑ∞ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû•ÍπåÏßÄÏùò Ï†ÑÏ≤¥ ÌùêÎ¶Ñ Î∂ÑÏÑù
3. **ÏÑ±Îä• Î≥ëÎ™© ÏãùÎ≥Ñ**: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨, ÎÑ§Ìä∏ÏõåÌÅ¨ ÏßÄÏó∞, UI Î†åÎçîÎßÅ Î≥ëÎ™© ÌååÏïÖ
4. **ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù**: UI ÌëúÏãúÏôÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Îç∞Ïù¥ÌÑ∞ Í∞Ñ ÏùºÍ¥ÄÏÑ± ÌôïÏù∏
5. **ÌôïÏû•ÏÑ± ÌèâÍ∞Ä**: ÏÇ¨Ïö©Ïûê Ï¶ùÍ∞ÄÏóê Îî∞Î•∏ ÏãúÏä§ÌÖú ÌôïÏû•ÏÑ± ÌèâÍ∞Ä

### 1.3 Ïã§Ï†ú Íµ¨ÌòÑ Í≥†Î†§ÏÇ¨Ìï≠

#### 1.3.1 Streamlit ÌäπÏàòÏÑ± Í≥†Î†§
Streamlit Í∏∞Î∞ò Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏùò ÌäπÏàòÏÑ±ÏùÑ Í≥†Î†§Ìïú UI-Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≥Ñ:

```python
# Streamlit ÏÑ∏ÏÖò ÏÉÅÌÉúÏôÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Îèô ÏòàÏ†ú
import streamlit as st
import asyncpg
from typing import Dict, Any, List

class StreamlitDatabaseBridge:
    """StreamlitÍ≥º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Îèô Î∏åÎ¶øÏßÄ"""
    
    def __init__(self, db_url: str):
        self.db_url = db_url
        self.pool = None
    
    async def initialize(self):
        """ÎπÑÎèôÍ∏∞ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌíÄ Ï¥àÍ∏∞Ìôî"""
        self.pool = await asyncpg.create_pool(self.db_url)
    
    def get_cached_data(self, key: str, default=None):
        """Streamlit ÏÑ∏ÏÖò ÏÉÅÌÉúÏóêÏÑú Ï∫êÏãúÎêú Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        return st.session_state.get(key, default)
    
    def set_cached_data(self, key: str, value: Any):
        """Streamlit ÏÑ∏ÏÖò ÏÉÅÌÉúÏóê Îç∞Ïù¥ÌÑ∞ Ï∫êÏãú"""
        st.session_state[key] = value
    
    async def execute_query(self, query: str, *params):
        """ÎπÑÎèôÍ∏∞ ÏøºÎ¶¨ Ïã§Ìñâ Î∞è Í≤∞Í≥º Ï∫êÏã±"""
        cache_key = f"query_{hash(query)}_{hash(str(params))}"
        
        # ÏÑ∏ÏÖò ÏÉÅÌÉúÏóêÏÑú Ï∫êÏãú ÌôïÏù∏
        cached_result = self.get_cached_data(cache_key)
        if cached_result:
            return cached_result
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨ Ïã§Ìñâ
        async with self.pool.acquire() as conn:
            result = await conn.fetch(query, *params)
        
        # Í≤∞Í≥º Ï∫êÏã± (ÏÑ∏ÏÖò ÎèôÏïàÎßå Ïú†ÏßÄ)
        self.set_cached_data(cache_key, result)
        
        return result

# ÏÇ¨Ïö© ÏòàÏ†ú
@st.cache_data(ttl=300)  # 5Î∂Ñ Ï∫êÏãú
def get_stock_data(symbol: str):
    """Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (Streamlit Ï∫êÏãú ÏÇ¨Ïö©)"""
    db_bridge = st.session_state.get('db_bridge')
    if not db_bridge:
        return None
    
    # ÎπÑÎèôÍ∏∞ Ìï®ÏàòÎ•º ÎèôÍ∏∞ ÌôòÍ≤ΩÏóêÏÑú Ïã§Ìñâ
    import asyncio
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
    
    query = """
    SELECT symbol, company_name, current_price, previous_close,
           day_change, day_change_pct, volume
    FROM unified_stocks_v2
    WHERE symbol = $1
    """
    
    return loop.run_until_complete(
        db_bridge.execute_query(query, symbol)
    )
```

#### 1.3.2 ÏÑ±Îä• ÏµúÏ†ÅÌôî Ï†ÑÎûµ

```python
# ÏÑ±Îä• ÏµúÏ†ÅÌôîÎêú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑúÎπÑÏä§
import asyncio
from typing import List, Dict, Any, Optional
import time

class OptimizedDatabaseService:
    """ÏÑ±Îä• ÏµúÏ†ÅÌôîÎêú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑúÎπÑÏä§"""
    
    def __init__(self, db_pool, redis_client):
        self.db_pool = db_pool
        self.redis = redis_client
        self.query_cache = {}
        self.performance_metrics = {
            'query_count': 0,
            'cache_hits': 0,
            'avg_query_time': 0
        }
    
    async def get_stocks_with_sentiment(self, limit: int = 50) -> List[Dict[str, Any]]:
        """ÏÑºÌã∞Î®ºÌä∏ Ï†ïÎ≥¥Í∞Ä Ìè¨Ìï®Îêú Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (ÏµúÏ†ÅÌôî)"""
        start_time = time.time()
        
        # Ï∫êÏãú ÌÇ§ ÏÉùÏÑ±
        cache_key = f"stocks_with_sentiment_{limit}"
        
        # Redis Ï∫êÏãú ÌôïÏù∏
        cached_data = await self.redis.get(cache_key)
        if cached_data:
            self.performance_metrics['cache_hits'] += 1
            return json.loads(cached_data)
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨ (ÏµúÏ†ÅÌôî)
        query = """
        SELECT
            us.symbol, us.company_name, us.current_price,
            us.previous_close, us.day_change, us.day_change_pct,
            us.volume, us.market_cap, us.overall_sentiment,
            us.mention_count_24h, us.trending_status, us.trend_score,
            -- ÏÑºÌã∞Î®ºÌä∏ ÏÑúÎ∏åÏøºÎ¶¨ ÏµúÏ†ÅÌôî
            (SELECT COUNT(*) FROM stock_mentions sm
             WHERE sm.symbol = us.symbol
             AND sm.timestamp > NOW() - INTERVAL '24 hours') as recent_mentions
        FROM unified_stocks_v2 us
        WHERE us.current_price IS NOT NULL
        ORDER BY
            CASE WHEN us.trending_status = true THEN 1 ELSE 2 END,
            us.trend_score DESC NULLS LAST,
            us.mention_count_24h DESC NULLS LAST
        LIMIT $1
        """
        
        async with self.db_pool.acquire() as conn:
            rows = await conn.fetch(query, limit)
        
        # Í≤∞Í≥º Î≥ÄÌôò
        results = []
        for row in rows:
            results.append({
                'symbol': row['symbol'],
                'company_name': row['company_name'],
                'current_price': float(row['current_price']),
                'previous_close': float(row['previous_close']),
                'day_change': float(row['day_change']),
                'day_change_pct': float(row['day_change_pct']),
                'volume': row['volume'],
                'market_cap': row['market_cap'],
                'overall_sentiment': float(row['overall_sentiment']) if row['overall_sentiment'] else None,
                'mention_count_24h': row['mention_count_24h'],
                'trending_status': row['trending_status'],
                'trend_score': float(row['trend_score']) if row['trend_score'] else None,
                'recent_mentions': row['recent_mentions']
            })
        
        # Redis Ï∫êÏãú Ï†ÄÏû• (5Î∂Ñ TTL)
        await self.redis.setex(cache_key, 300, json.dumps(results, default=str))
        
        # ÏÑ±Îä• Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
        query_time = time.time() - start_time
        self.performance_metrics['query_count'] += 1
        self.performance_metrics['avg_query_time'] = (
            (self.performance_metrics['avg_query_time'] * (self.performance_metrics['query_count'] - 1) + query_time) /
            self.performance_metrics['query_count']
        )
        
        return results
    
    async def get_time_series_data(self, symbol: str, period: str = "1M") -> List[Dict[str, Any]]:
        """ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå (TimescaleDB ÏµúÏ†ÅÌôî)"""
        start_time = time.time()
        
        # Ï∫êÏãú ÌÇ§ ÏÉùÏÑ±
        cache_key = f"timeseries_{symbol}_{period}"
        
        # Redis Ï∫êÏãú ÌôïÏù∏
        cached_data = await self.redis.get(cache_key)
        if cached_data:
            self.performance_metrics['cache_hits'] += 1
            return json.loads(cached_data)
        
        # Í∏∞Í∞ÑÏóê Îî∞Î•∏ ÏãúÍ∞Ñ Ï°∞Í±¥
        time_conditions = {
            "1D": "NOW() - INTERVAL '1 day'",
            "1W": "NOW() - INTERVAL '1 week'",
            "1M": "NOW() - INTERVAL '1 month'",
            "3M": "NOW() - INTERVAL '3 months'",
            "1Y": "NOW() - INTERVAL '1 year'"
        }
        
        time_condition = time_conditions.get(period, time_conditions["1M"])
        
        # TimescaleDB ÏµúÏ†ÅÌôî ÏøºÎ¶¨
        query = f"""
        SELECT
            time_bucket('1 hour', time) as hour,
            FIRST(open_price, time) as open,
            MAX(high_price) as high,
            MIN(low_price) as low,
            LAST(close_price, time) as close,
            SUM(volume) as volume
        FROM stock_prices_timescale
        WHERE symbol = $1 AND time >= {time_condition}
        GROUP BY hour
        ORDER BY hour
        """
        
        async with self.db_pool.acquire() as conn:
            rows = await conn.fetch(query, symbol)
        
        # Í≤∞Í≥º Î≥ÄÌôò
        results = []
        for row in rows:
            results.append({
                'time': row['hour'].isoformat(),
                'open': float(row['open']),
                'high': float(row['high']),
                'low': float(row['low']),
                'close': float(row['close']),
                'volume': row['volume']
            })
        
        # Redis Ï∫êÏãú Ï†ÄÏû• (Í∏∞Í∞ÑÎ≥Ñ TTL)
        ttl_map = {"1D": 60, "1W": 300, "1M": 600, "3M": 1800, "1Y": 3600}
        await self.redis.setex(cache_key, ttl_map.get(period, 600), json.dumps(results))
        
        # ÏÑ±Îä• Î©îÌä∏Î¶≠ ÏóÖÎç∞Ïù¥Ìä∏
        query_time = time.time() - start_time
        self.performance_metrics['query_count'] += 1
        self.performance_metrics['avg_query_time'] = (
            (self.performance_metrics['avg_query_time'] * (self.performance_metrics['query_count'] - 1) + query_time) /
            self.performance_metrics['query_count']
        )
        
        return results
    
    def get_performance_metrics(self) -> Dict[str, Any]:
        """ÏÑ±Îä• Î©îÌä∏Î¶≠ Ï°∞Ìöå"""
        cache_hit_rate = (
            self.performance_metrics['cache_hits'] /
            max(self.performance_metrics['query_count'], 1)
        ) * 100
        
        return {
            **self.performance_metrics,
            'cache_hit_rate': f"{cache_hit_rate:.2f}%",
            'total_queries': self.performance_metrics['query_count'],
            'cache_hits': self.performance_metrics['cache_hits']
        }
```

#### 1.3.3 Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨

```python
# Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨Î•º ÏúÑÌïú WebSocket Ïó∞Îèô
import asyncio
import websockets
import json
from typing import Set, Dict, Any
from datetime import datetime

class RealTimeDataManager:
    """Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Í¥ÄÎ¶¨Ïûê"""
    
    def __init__(self, db_pool, redis_client):
        self.db_pool = db_pool
        self.redis = redis_client
        self.connected_clients: Set[websockets.WebSocketServerProtocol] = set()
        self.subscriptions: Dict[str, Set[websockets.WebSocketServerProtocol]] = {}
    
    async def register_client(self, websocket: websockets.WebSocketServerProtocol):
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îì±Î°ù"""
        self.connected_clients.add(websocket)
        print(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞Îê®. Ï¥ù ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏: {len(self.connected_clients)}")
        
        # ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÍ≤å Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°
        await self.send_initial_data(websocket)
    
    async def unregister_client(self, websocket: websockets.WebSocketServerProtocol):
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ìï¥Ï†ú"""
        self.connected_clients.discard(websocket)
        
        # Íµ¨ÎèÖ Ï†ïÎ≥¥ÏóêÏÑú Ï†úÍ±∞
        for symbol, clients in self.subscriptions.items():
            clients.discard(websocket)
            if not clients:
                del self.subscriptions[symbol]
        
        print(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ìï¥Ï†úÎê®. Ï¥ù ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏: {len(self.connected_clients)}")
    
    async def subscribe_symbol(self, websocket: websockets.WebSocketServerProtocol, symbol: str):
        """Ïã¨Î≥º Íµ¨ÎèÖ"""
        if symbol not in self.subscriptions:
            self.subscriptions[symbol] = set()
        self.subscriptions[symbol].add(websocket)
        
        # ÌòÑÏû¨ Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°
        current_data = await self.get_current_stock_data(symbol)
        if current_data:
            await websocket.send(json.dumps({
                'type': 'stock_data',
                'symbol': symbol,
                'data': current_data,
                'timestamp': datetime.utcnow().isoformat()
            }))
    
    async def send_initial_data(self, websocket: websockets.WebSocketServerProtocol):
        """Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°"""
        # Ìä∏Î†åÎî© Ï£ºÏãù Ï†ÑÏÜ°
        trending_stocks = await self.get_trending_stocks()
        await websocket.send(json.dumps({
            'type': 'trending_stocks',
            'data': trending_stocks,
            'timestamp': datetime.utcnow().isoformat()
        }))
        
        # ÏãúÏû• ÏöîÏïΩ Ï†ÑÏÜ°
        market_summary = await self.get_market_summary()
        await websocket.send(json.dumps({
            'type': 'market_summary',
            'data': market_summary,
            'timestamp': datetime.utcnow().isoformat()
        }))
    
    async def broadcast_price_update(self, symbol: str, price_data: Dict[str, Any]):
        """Í∞ÄÍ≤© ÏóÖÎç∞Ïù¥Ìä∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏"""
        if symbol in self.subscriptions:
            message = json.dumps({
                'type': 'price_update',
                'symbol': symbol,
                'data': price_data,
                'timestamp': datetime.utcnow().isoformat()
            })
            
            # Íµ¨ÎèÖÌïú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÍ≤å Ï†ÑÏÜ°
            disconnected_clients = set()
            for client in self.subscriptions[symbol]:
                try:
                    await client.send(message)
                except websockets.exceptions.ConnectionClosed:
                    disconnected_clients.add(client)
                except Exception as e:
                    print(f"ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÍ≤å Ï†ÑÏÜ° Ï§ë Ïò§Î•ò: {e}")
                    disconnected_clients.add(client)
            
            # Ïó∞Í≤∞ ÎÅäÍ∏¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†ïÎ¶¨
            for client in disconnected_clients:
                await self.unregister_client(client)
    
    async def get_current_stock_data(self, symbol: str) -> Optional[Dict[str, Any]]:
        """ÌòÑÏû¨ Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        async with self.db_pool.acquire() as conn:
            try:
                row = await conn.fetchrow("""
                SELECT
                    symbol, company_name, current_price, previous_close,
                    day_change, day_change_pct, volume, market_cap,
                    overall_sentiment, mention_count_24h, trending_status
                FROM unified_stocks_v2
                WHERE symbol = $1
                """, symbol)
                
                if row:
                    return {
                        'symbol': row['symbol'],
                        'company_name': row['company_name'],
                        'current_price': float(row['current_price']) if row['current_price'] else None,
                        'previous_close': float(row['previous_close']) if row['previous_close'] else None,
                        'day_change': float(row['day_change']) if row['day_change'] else None,
                        'day_change_pct': float(row['day_change_pct']) if row['day_change_pct'] else None,
                        'volume': row['volume'],
                        'market_cap': row['market_cap'],
                        'overall_sentiment': float(row['overall_sentiment']) if row['overall_sentiment'] else None,
                        'mention_count_24h': row['mention_count_24h'],
                        'trending_status': row['trending_status']
                    }
                return None
            except Exception as e:
                print(f"Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïò§Î•ò: {e}")
                return None
    
    async def get_trending_stocks(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Ìä∏Î†åÎî© Ï£ºÏãù Ï°∞Ìöå"""
        async with self.db_pool.acquire() as conn:
            try:
                rows = await conn.fetch("""
                SELECT
                    symbol, company_name, current_price, day_change_pct,
                    overall_sentiment, mention_count_24h, trend_score
                FROM unified_stocks_v2
                WHERE trending_status = true
                ORDER BY trend_score DESC NULLS LAST, mention_count_24h DESC
                LIMIT $1
                """, limit)
                
                return [{
                    'symbol': row['symbol'],
                    'company_name': row['company_name'],
                    'current_price': float(row['current_price']) if row['current_price'] else None,
                    'day_change_pct': float(row['day_change_pct']) if row['day_change_pct'] else None,
                    'overall_sentiment': float(row['overall_sentiment']) if row['overall_sentiment'] else None,
                    'mention_count_24h': row['mention_count_24h'],
                    'trend_score': float(row['trend_score']) if row['trend_score'] else None
                } for row in rows]
            except Exception as e:
                print(f"Ìä∏Î†åÎî© Ï£ºÏãù Ï°∞Ìöå Ïò§Î•ò: {e}")
                return []
    
    async def get_market_summary(self) -> Dict[str, Any]:
        """ÏãúÏû• ÏöîÏïΩ Ï°∞Ìöå"""
        async with self.db_pool.acquire() as conn:
            try:
                # Ï†ÑÏ≤¥ ÏãúÏû• ÏÑºÌã∞Î®ºÌä∏
                sentiment_row = await conn.fetchrow("""
                SELECT
                    AVG(overall_sentiment) as avg_sentiment,
                    COUNT(*) as total_stocks,
                    COUNT(CASE WHEN trending_status = true THEN 1 END) as trending_count
                FROM unified_stocks_v2
                WHERE current_price IS NOT NULL
                """)
                
                # ÏÉÅÏúÑ ÏÑπÌÑ∞
                sector_rows = await conn.fetch("""
                SELECT
                    sector,
                    COUNT(*) as stock_count,
                    AVG(day_change_pct) as avg_change_pct
                FROM unified_stocks_v2
                WHERE sector IS NOT NULL AND current_price IS NOT NULL
                GROUP BY sector
                ORDER BY stock_count DESC
                LIMIT 5
                """)
                
                return {
                    'avg_sentiment': float(sentiment_row['avg_sentiment']) if sentiment_row['avg_sentiment'] else 0,
                    'total_stocks': sentiment_row['total_stocks'],
                    'trending_count': sentiment_row['trending_count'],
                    'top_sectors': [{
                        'sector': row['sector'],
                        'stock_count': row['stock_count'],
                        'avg_change_pct': float(row['avg_change_pct']) if row['avg_change_pct'] else 0
                    } for row in sector_rows]
                }
            except Exception as e:
                print(f"ÏãúÏû• ÏöîÏïΩ Ï°∞Ìöå Ïò§Î•ò: {e}")
                return {}
```

## 2. Í∏∞Ï°¥ Î∂ÑÏÑù Î¨∏ÏÑú Ï¢ÖÌï© Í≤ÄÌÜ†

### 2.1 UI/UX Í∏∞Îä•Î≥Ñ ÏÉÅÏÑ∏ Î∂ÑÏÑù (docs/spec/21-ui-ux-feature-breakdown.md) Í≤ÄÌÜ† Í≤∞Í≥º

**Í∞ïÏ†ê**:
- Í∏∞Îä•Î≥Ñ UI ÏóòÎ¶¨Î®ºÌä∏ Ï≤¥Í≥ÑÏ†ÅÏúºÎ°ú Î∂ÑÎ•ò
- ÏÇ¨Ïö©Ïûê ÏãúÎÇòÎ¶¨Ïò§Î≥Ñ ÌùêÎ¶Ñ ÏÉÅÏÑ∏Ìûà Ï†ïÏùò
- Í∏∞Îä• Í∞Ñ Ïó∞Í≤∞ÏÑ± Î™ÖÌôïÌûà ÏÑ§Î™Ö

**Î≥¥ÏôÑÏ†ê**:
- Í∞Å UI ÏóòÎ¶¨Î®ºÌä∏Ïùò Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§ Î™ÖÏãú Î∂ÄÏ°±
- Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏îÍ≥ºÏùò ÏßÅÏ†ëÏ†ÅÏù∏ Îß§Ìïë Ï†ïÎ≥¥ ÎàÑÎùΩ
- Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏Î•º ÏúÑÌïú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Îèô Ï†ÑÎûµ Î∂ÄÏû¨

### 2.2 UI ÏóòÎ¶¨Î®ºÌä∏ ÌùêÎ¶Ñ Î∂ÑÏÑù (docs/spec/22-ui-workflow-analysis.md) Í≤ÄÌÜ† Í≤∞Í≥º

**Í∞ïÏ†ê**:
- ÏÇ¨Ïö©Ïûê ÌùêÎ¶ÑÏùÑ Mermaid Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏúºÎ°ú ÏãúÍ∞ÅÌôî
- Í∞Å Îã®Í≥ÑÎ≥Ñ ÏÉÅÌò∏ÏûëÏö© ÏÉÅÏÑ∏Ìûà Ï†ïÏùò
- ÏÇ¨Ïö©Ïûê ÏãúÎÇòÎ¶¨Ïò§Î≥Ñ ÌùêÎ¶Ñ Ï≤¥Í≥ÑÏ†ÅÏúºÎ°ú Î∂ÑÏÑù

**Î≥¥ÏôÑÏ†ê**:
- Í∞Å ÌùêÎ¶Ñ Îã®Í≥ÑÏóêÏÑú ÌïÑÏöîÌïú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏøºÎ¶¨ Î™ÖÏãú Î∂ÄÏ°±
- Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìä∏ÎûúÏû≠ÏÖò Ï≤òÎ¶¨ Î°úÏßÅ ÏÑ§Î™Ö Î∂ÄÏû¨
- ÏóêÎü¨ Î∞úÏÉù Ïãú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î°§Î∞± Ï†ÑÎûµ ÎàÑÎùΩ

### 2.3 UI ÏóòÎ¶¨Î®ºÌä∏ÏôÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Îß§Ìïë Î∂ÑÏÑù (docs/spec/23-ui-database-mapping.md) Í≤ÄÌÜ† Í≤∞Í≥º

**Í∞ïÏ†ê**:
- UI ÏóòÎ¶¨Î®ºÌä∏ÏôÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏î Îß§Ìïë ÌëúÎ°ú ÏÉÅÏÑ∏Ìûà Ï†ïÎ¶¨
- ÎàÑÎùΩÎêú ÌÖåÏù¥Î∏îÍ≥º ÌïÑÎìú ÏãùÎ≥Ñ Î∞è SQL Ïä§ÌÇ§Îßà Ï†úÍ≥µ
- Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≥Ñ Îã§Ïù¥Ïñ¥Í∑∏Îû®ÏúºÎ°ú Í¥ÄÍ≥Ñ ÏãúÍ∞ÅÌôî

**Î≥¥ÏôÑÏ†ê**:
- Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞ÌôîÎ•º ÏúÑÌïú Ìä∏Î¶¨Í±∞ Î∞è ÌîÑÎ°úÏãúÏ†Ä Ï†ïÏùò Î∂ÄÏ°±
- Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïù∏Îç±Ïã± Ï†ÑÎûµ ÏÉÅÏÑ∏Ìûà ÏÑ§Î™Ö Î∂ÄÏû¨
- Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Ïú†ÏßÄÎ•º ÏúÑÌïú Ï†úÏïΩ Ï°∞Í±¥ Ï†ïÏùò Î∂ÄÏ°±

## 3. ÌÜµÌï© Îç∞Ïù¥ÌÑ∞ Î™®Îç∏Í≥ºÏùò Ïó∞Í≥Ñ Í≤ÄÌÜ†

### 3.1 UnifiedStockData Î™®Îç∏ Ïó∞Í≥Ñ Î∂ÑÏÑù

```mermaid
graph TB
    subgraph "UI ÏóòÎ¶¨Î®ºÌä∏"
        A[Í≤ÄÏÉâ Í≤∞Í≥º]
        B[Ï£ºÏãù ÏÉÅÏÑ∏ Ï†ïÎ≥¥]
        C[ÏÑºÌã∞Î®ºÌä∏ Î∂ÑÏÑù]
        D[Í¥ÄÏã¨Ï¢ÖÎ™©]
        E[Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞]
    end
    
    subgraph "UnifiedStockData Î™®Îç∏"
        F[Í∏∞Î≥∏ Ï†ïÎ≥¥]
        G[Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞]
        H[ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞]
        I[Í≤ÄÏÉâ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞]
        J[Í¥ÄÏã¨Ï¢ÖÎ™© Î©îÌÉÄÎç∞Ïù¥ÌÑ∞]
    end
    
    subgraph "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏î"
        K[stocks]
        L[stock_prices]
        M[sentiment_timeseries]
        N[search_history]
        O[watchlists]
        P[unified_stocks]
    end
    
    A --> F
    A --> I
    B --> F
    B --> G
    C --> H
    D --> J
    E --> G
    
    F --> K
    F --> P
    G --> L
    G --> P
    H --> M
    H --> P
    I --> N
    J --> O
```

**Î∞úÍ≤¨Îêú Î¨∏Ï†úÏ†ê**:
1. **Îç∞Ïù¥ÌÑ∞ Ï§ëÎ≥µ**: unified_stocks ÌÖåÏù¥Î∏îÍ≥º Í∞úÎ≥Ñ ÌÖåÏù¥Î∏î Í∞Ñ Îç∞Ïù¥ÌÑ∞ Ï§ëÎ≥µ Î∞úÏÉù
2. **ÎèôÍ∏∞Ìôî Î≥µÏû°ÏÑ±**: Ïó¨Îü¨ ÌÖåÏù¥Î∏î Í∞Ñ Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞Ìôî Î°úÏßÅ Î≥µÏû°
3. **ÏÑ±Îä• Ï†ÄÌïò**: JSON ÌïÑÎìú ÏÇ¨Ïö©ÏúºÎ°ú Ïù∏Ìïú ÏøºÎ¶¨ ÏÑ±Îä• Ï†ÄÌïò Í∞ÄÎä•ÏÑ±

### 3.2 Í∞úÏÑ†Îêú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà Ï†úÏïà

```sql
-- ÌÜµÌï© Ï£ºÏãù Ï†ïÎ≥¥ ÌÖåÏù¥Î∏î (Í∞úÏÑ†Ïïà)
CREATE TABLE unified_stocks_v2 (
    symbol VARCHAR(20) PRIMARY KEY,
    company_name VARCHAR(255) NOT NULL,
    stock_type VARCHAR(20) NOT NULL,
    exchange VARCHAR(50) NOT NULL,
    sector VARCHAR(100),
    industry VARCHAR(100),
    description TEXT,
    website VARCHAR(255),
    
    -- Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ (Ï†ïÍ∑úÌôî)
    current_price DECIMAL(10, 2),
    previous_close DECIMAL(10, 2),
    day_change DECIMAL(10, 2),
    day_change_pct DECIMAL(5, 2),
    volume BIGINT,
    market_cap BIGINT,
    pe_ratio DECIMAL(8, 2),
    dividend_yield DECIMAL(5, 4),
    beta DECIMAL(5, 4),
    
    -- ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ (Ï†ïÍ∑úÌôî)
    overall_sentiment DECIMAL(3, 2),
    mention_count_24h INTEGER DEFAULT 0,
    trending_status BOOLEAN DEFAULT false,
    trend_score DECIMAL(5, 2),
    
    -- Î©îÌÉÄÎç∞Ïù¥ÌÑ∞
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    data_quality_score DECIMAL(3, 2) DEFAULT 1.0,
    
    -- Ïù∏Îç±Ïä§
    INDEX idx_unified_stocks_sector (sector),
    INDEX idx_unified_stocks_trending (trending_status, trend_score DESC),
    INDEX idx_unified_stocks_sentiment (overall_sentiment DESC),
    INDEX idx_unified_stocks_updated (last_updated DESC)
);

-- ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏î (TimescaleDB)
CREATE TABLE stock_prices_timescale (
    time TIMESTAMP NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    open_price DECIMAL(10, 2),
    high_price DECIMAL(10, 2),
    low_price DECIMAL(10, 2),
    close_price DECIMAL(10, 2),
    volume BIGINT,
    adj_close_price DECIMAL(10, 2),
    PRIMARY KEY (time, symbol)
);

SELECT create_hypertable('stock_prices_timescale', 'time', chunk_time_interval => INTERVAL '1 hour');

-- ÏÑºÌã∞Î®ºÌä∏ ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏î (TimescaleDB)
CREATE TABLE sentiment_timeseries_v2 (
    time TIMESTAMP NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    sentiment_score DECIMAL(3, 2),
    mention_count INTEGER,
    positive_count INTEGER,
    negative_count INTEGER,
    neutral_count INTEGER,
    source VARCHAR(20),
    PRIMARY KEY (time, symbol, source)
);

SELECT create_hypertable('sentiment_timeseries_v2', 'time', chunk_time_interval => INTERVAL '1 day');
```

## 4. Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ïó∞Îèô Ï†ÑÎûµ

### 4.1 WebSocketÏùÑ ÌÜµÌïú Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ïó∞Îèô

```python
# real_time_data_sync.py
import asyncio
import websockets
import json
from typing import Dict, List, Set
from datetime import datetime

class RealTimeDataSync:
    """Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞Ìôî Í¥ÄÎ¶¨Ïûê"""
    
    def __init__(self, db_pool, redis_client):
        self.db_pool = db_pool
        self.redis = redis_client
        self.connected_clients: Set[websockets.WebSocketServerProtocol] = set()
        self.subscription_map: Dict[str, Set[websockets.WebSocketServerProtocol]] = {}
    
    async def register_client(self, websocket: websockets.WebSocketServerProtocol):
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Îì±Î°ù"""
        self.connected_clients.add(websocket)
        print(f"Client connected. Total clients: {len(self.connected_clients)}")
    
    async def unregister_client(self, websocket: websockets.WebSocketServerProtocol):
        """ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ìï¥Ï†ú"""
        self.connected_clients.discard(websocket)
        
        # Íµ¨ÎèÖ Ï†ïÎ≥¥ÏóêÏÑú Ï†úÍ±∞
        for symbol, clients in self.subscription_map.items():
            clients.discard(websocket)
            if not clients:
                del self.subscription_map[symbol]
        
        print(f"Client disconnected. Total clients: {len(self.connected_clients)}")
    
    async def subscribe_symbol(self, websocket: websockets.WebSocketServerProtocol, symbol: str):
        """Ïã¨Î≥º Íµ¨ÎèÖ"""
        if symbol not in self.subscription_map:
            self.subscription_map[symbol] = set()
        self.subscription_map[symbol].add(websocket)
        
        # ÌòÑÏû¨ Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°
        current_data = await self.get_current_stock_data(symbol)
        if current_data:
            await websocket.send(json.dumps({
                'type': 'stock_data',
                'symbol': symbol,
                'data': current_data
            }))
    
    async def unsubscribe_symbol(self, websocket: websockets.WebSocketServerProtocol, symbol: str):
        """Ïã¨Î≥º Íµ¨ÎèÖ Ìï¥Ï†ú"""
        if symbol in self.subscription_map:
            self.subscription_map[symbol].discard(websocket)
            if not self.subscription_map[symbol]:
                del self.subscription_map[symbol]
    
    async def broadcast_price_update(self, symbol: str, price_data: dict):
        """Í∞ÄÍ≤© ÏóÖÎç∞Ïù¥Ìä∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏"""
        if symbol in self.subscription_map:
            message = json.dumps({
                'type': 'price_update',
                'symbol': symbol,
                'data': price_data,
                'timestamp': datetime.utcnow().isoformat()
            })
            
            # Íµ¨ÎèÖÌïú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÍ≤å Ï†ÑÏÜ°
            disconnected_clients = set()
            for client in self.subscription_map[symbol]:
                try:
                    await client.send(message)
                except websockets.exceptions.ConnectionClosed:
                    disconnected_clients.add(client)
                except Exception as e:
                    print(f"Error sending to client: {e}")
                    disconnected_clients.add(client)
            
            # Ïó∞Í≤∞ ÎÅäÍ∏¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†ïÎ¶¨
            for client in disconnected_clients:
                await self.unregister_client(client)
    
    async def broadcast_sentiment_update(self, symbol: str, sentiment_data: dict):
        """ÏÑºÌã∞Î®ºÌä∏ ÏóÖÎç∞Ïù¥Ìä∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏"""
        if symbol in self.subscription_map:
            message = json.dumps({
                'type': 'sentiment_update',
                'symbol': symbol,
                'data': sentiment_data,
                'timestamp': datetime.utcnow().isoformat()
            })
            
            # Íµ¨ÎèÖÌïú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÍ≤å Ï†ÑÏÜ°
            disconnected_clients = set()
            for client in self.subscription_map[symbol]:
                try:
                    await client.send(message)
                except websockets.exceptions.ConnectionClosed:
                    disconnected_clients.add(client)
                except Exception as e:
                    print(f"Error sending to client: {e}")
                    disconnected_clients.add(client)
            
            # Ïó∞Í≤∞ ÎÅäÍ∏¥ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï†ïÎ¶¨
            for client in disconnected_clients:
                await self.unregister_client(client)
    
    async def get_current_stock_data(self, symbol: str) -> dict:
        """ÌòÑÏû¨ Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        async with self.db_pool.acquire() as conn:
            try:
                query = """
                SELECT 
                    symbol, company_name, current_price, previous_close,
                    day_change, day_change_pct, volume, market_cap,
                    overall_sentiment, mention_count_24h, trending_status,
                    last_updated
                FROM unified_stocks_v2
                WHERE symbol = $1
                """
                row = await conn.fetchrow(query, symbol)
                
                if row:
                    return {
                        'symbol': row['symbol'],
                        'company_name': row['company_name'],
                        'current_price': float(row['current_price']) if row['current_price'] else None,
                        'previous_close': float(row['previous_close']) if row['previous_close'] else None,
                        'day_change': float(row['day_change']) if row['day_change'] else None,
                        'day_change_pct': float(row['day_change_pct']) if row['day_change_pct'] else None,
                        'volume': row['volume'],
                        'market_cap': row['market_cap'],
                        'overall_sentiment': float(row['overall_sentiment']) if row['overall_sentiment'] else None,
                        'mention_count_24h': row['mention_count_24h'],
                        'trending_status': row['trending_status'],
                        'last_updated': row['last_updated'].isoformat() if row['last_updated'] else None
                    }
                return None
            except Exception as e:
                print(f"Error fetching stock data: {e}")
                return None
    
    async def update_stock_data(self, symbol: str, price_data: dict):
        """Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏"""
        async with self.db_pool.acquire() as conn:
            try:
                query = """
                UPDATE unified_stocks_v2
                SET 
                    current_price = $2,
                    previous_close = $3,
                    day_change = $4,
                    day_change_pct = $5,
                    volume = $6,
                    last_updated = CURRENT_TIMESTAMP
                WHERE symbol = $1
                """
                await conn.execute(
                    query,
                    symbol,
                    price_data.get('current_price'),
                    price_data.get('previous_close'),
                    price_data.get('day_change'),
                    price_data.get('day_change_pct'),
                    price_data.get('volume')
                )
                
                # Ïã§ÏãúÍ∞Ñ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
                await self.broadcast_price_update(symbol, price_data)
                
                # Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
                await self.redis.setex(
                    f"stock:{symbol}",
                    300,  # 5Î∂Ñ TTL
                    json.dumps(price_data, default=str)
                )
                
            except Exception as e:
                print(f"Error updating stock data: {e}")
    
    async def update_sentiment_data(self, symbol: str, sentiment_data: dict):
        """ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏"""
        async with self.db_pool.acquire() as conn:
            try:
                query = """
                UPDATE unified_stocks_v2
                SET 
                    overall_sentiment = $2,
                    mention_count_24h = $3,
                    trending_status = $4,
                    trend_score = $5,
                    last_updated = CURRENT_TIMESTAMP
                WHERE symbol = $1
                """
                await conn.execute(
                    query,
                    symbol,
                    sentiment_data.get('overall_sentiment'),
                    sentiment_data.get('mention_count_24h'),
                    sentiment_data.get('trending_status'),
                    sentiment_data.get('trend_score')
                )
                
                # Ïã§ÏãúÍ∞Ñ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
                await self.broadcast_sentiment_update(symbol, sentiment_data)
                
                # Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
                await self.redis.setex(
                    f"sentiment:{symbol}",
                    300,  # 5Î∂Ñ TTL
                    json.dumps(sentiment_data, default=str)
                )
                
            except Exception as e:
                print(f"Error updating sentiment data: {e}")
```

### 4.2 Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìä∏Î¶¨Í±∞Î•º ÌÜµÌïú ÏûêÎèô ÎèôÍ∏∞Ìôî

```sql
-- Ï£ºÏãù Í∞ÄÍ≤© ÏóÖÎç∞Ïù¥Ìä∏ Ìä∏Î¶¨Í±∞
CREATE OR REPLACE FUNCTION notify_price_update()
RETURNS TRIGGER AS $$
BEGIN
    -- RedisÏóê ÏóÖÎç∞Ïù¥Ìä∏ ÏïåÎ¶º
    PERFORM pg_notify('price_update', 
        json_build_object(
            'symbol', NEW.symbol,
            'current_price', NEW.current_price,
            'previous_close', NEW.previous_close,
            'day_change', NEW.day_change,
            'day_change_pct', NEW.day_change_pct,
            'volume', NEW.volume,
            'timestamp', NOW()
        )::text
    );
    
    -- ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏îÏóê Í∏∞Î°ù
    INSERT INTO stock_prices_timescale (
        time, symbol, close_price, volume
    ) VALUES (
        NOW(), NEW.symbol, NEW.current_price, NEW.volume
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_price_update
    AFTER UPDATE ON unified_stocks_v2
    FOR EACH ROW
    WHEN (OLD.current_price IS DISTINCT FROM NEW.current_price)
    EXECUTE FUNCTION notify_price_update();

-- ÏÑºÌã∞Î®ºÌä∏ ÏóÖÎç∞Ïù¥Ìä∏ Ìä∏Î¶¨Í±∞
CREATE OR REPLACE FUNCTION notify_sentiment_update()
RETURNS TRIGGER AS $$
BEGIN
    -- RedisÏóê ÏóÖÎç∞Ïù¥Ìä∏ ÏïåÎ¶º
    PERFORM pg_notify('sentiment_update', 
        json_build_object(
            'symbol', NEW.symbol,
            'overall_sentiment', NEW.overall_sentiment,
            'mention_count_24h', NEW.mention_count_24h,
            'trending_status', NEW.trending_status,
            'trend_score', NEW.trend_score,
            'timestamp', NOW()
        )::text
    );
    
    -- ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ ÌÖåÏù¥Î∏îÏóê Í∏∞Î°ù
    INSERT INTO sentiment_timeseries_v2 (
        time, symbol, sentiment_score, mention_count
    ) VALUES (
        NOW(), NEW.symbol, NEW.overall_sentiment, NEW.mention_count_24h
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_sentiment_update
    AFTER UPDATE ON unified_stocks_v2
    FOR EACH ROW
    WHEN (OLD.overall_sentiment IS DISTINCT FROM NEW.overall_sentiment)
    EXECUTE FUNCTION notify_sentiment_update();
```

## 5. UI Ïª¥Ìè¨ÎÑåÌä∏Î≥Ñ Îç∞Ïù¥ÌÑ∞ Ïó∞Îèô ÏÉÅÏÑ∏ Î∂ÑÏÑù

### 5.1 Í≤ÄÏÉâ Ïª¥Ìè¨ÎÑåÌä∏ Îç∞Ïù¥ÌÑ∞ Ïó∞Îèô

```python
# components/search_component.py
import streamlit as st
import asyncio
import json
from typing import List, Dict, Any, Optional
from services.database_service import DatabaseService
from services.cache_service import CacheService

class EnhancedSearchComponent:
    """Ìñ•ÏÉÅÎêú Í≤ÄÏÉâ Ïª¥Ìè¨ÎÑåÌä∏"""
    
    def __init__(self):
        self.db_service = DatabaseService()
        self.cache_service = CacheService()
        self.search_history = []
    
    def render(self):
        """Í≤ÄÏÉâ Ïª¥Ìè¨ÎÑåÌä∏ Î†åÎçîÎßÅ"""
        st.markdown("### üîç Enhanced Stock Search")
        
        # Í≤ÄÏÉâ ÏûÖÎ†•
        col_search, col_filters = st.columns([3, 1])
        
        with col_search:
            search_query = st.text_input(
                "Search stocks...",
                placeholder="Enter symbol or company name...",
                key="search_input"
            )
        
        with col_filters:
            if st.button("üîß Filters", key="filter_toggle"):
                st.session_state.show_filters = not st.session_state.get('show_filters', False)
        
        # Í≥†Í∏â ÌïÑÌÑ∞
        if st.session_state.get('show_filters', False):
            self._render_advanced_filters()
        
        # Í≤ÄÏÉâ Ïã§Ìñâ
        if search_query:
            with st.spinner("Searching..."):
                results = asyncio.run(self._perform_search(search_query))
                self._render_search_results(results)
    
    def _render_advanced_filters(self):
        """Í≥†Í∏â ÌïÑÌÑ∞ Î†åÎçîÎßÅ"""
        with st.expander("Advanced Filters", expanded=True):
            col1, col2, col3 = st.columns(3)
            
            with col1:
                stock_type = st.selectbox(
                    "Stock Type",
                    ["All", "EQUITY", "ETF", "MUTUAL_FUND", "CRYPTO"],
                    key="filter_stock_type"
                )
                
                min_price = st.number_input(
                    "Min Price",
                    min_value=0.0,
                    value=0.0,
                    step=0.01,
                    key="filter_min_price"
                )
            
            with col2:
                exchange = st.selectbox(
                    "Exchange",
                    ["All", "NASDAQ", "NYSE", "AMEX"],
                    key="filter_exchange"
                )
                
                max_price = st.number_input(
                    "Max Price",
                    min_value=0.0,
                    value=10000.0,
                    step=0.01,
                    key="filter_max_price"
                )
            
            with col3:
                sector = st.selectbox(
                    "Sector",
                    ["All", "Technology", "Healthcare", "Finance", "Energy"],
                    key="filter_sector"
                )
                
                min_sentiment = st.slider(
                    "Min Sentiment",
                    min_value=-1.0,
                    max_value=1.0,
                    value=-1.0,
                    step=0.1,
                    key="filter_min_sentiment"
                )
    
    async def _perform_search(self, query: str) -> List[Dict[str, Any]]:
        """Í≤ÄÏÉâ ÏàòÌñâ"""
        # Ï∫êÏãú ÌôïÏù∏
        cache_key = f"search:{query}:{hash(str(st.session_state.get('filters', {})))}"
        cached_results = await self.cache_service.get(cache_key)
        
        if cached_results:
            return cached_results
        
        try:
            # ÌïÑÌÑ∞ Ï°∞Í±¥ÊûÑÂª∫
            filters = self._build_filters()
            
            # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í≤ÄÏÉâ
            results = await self.db_service.search_stocks(query, filters)
            
            # Í≤ÄÏÉâ Í∏∞Î°ù Ï†ÄÏû•
            await self._save_search_history(query, len(results))
            
            # Í≤∞Í≥º Ï∫êÏã±
            await self.cache_service.set(cache_key, results, ttl=300)
            
            return results
            
        except Exception as e:
            st.error(f"Search error: {str(e)}")
            return []
    
    def _build_filters(self) -> Dict[str, Any]:
        """ÌïÑÌÑ∞ Ï°∞Í±¥ÊûÑÂª∫"""
        filters = {}
        
        # Ï£ºÏãù Ïú†Ìòï ÌïÑÌÑ∞
        stock_type = st.session_state.get('filter_stock_type', 'All')
        if stock_type != 'All':
            filters['stock_type'] = stock_type
        
        # Í±∞ÎûòÏÜå ÌïÑÌÑ∞
        exchange = st.session_state.get('filter_exchange', 'All')
        if exchange != 'All':
            filters['exchange'] = exchange
        
        # ÏÑπÌÑ∞ ÌïÑÌÑ∞
        sector = st.session_state.get('filter_sector', 'All')
        if sector != 'All':
            filters['sector'] = sector
        
        # Í∞ÄÍ≤© Î≤îÏúÑ ÌïÑÌÑ∞
        min_price = st.session_state.get('filter_min_price', 0.0)
        max_price = st.session_state.get('filter_max_price', 10000.0)
        if min_price > 0.0 or max_price < 10000.0:
            filters['price_range'] = (min_price, max_price)
        
        # ÏÑºÌã∞Î®ºÌä∏ ÌïÑÌÑ∞
        min_sentiment = st.session_state.get('filter_min_sentiment', -1.0)
        if min_sentiment > -1.0:
            filters['min_sentiment'] = min_sentiment
        
        return filters
    
    async def _save_search_history(self, query: str, result_count: int):
        """Í≤ÄÏÉâ Í∏∞Î°ù Ï†ÄÏû•"""
        try:
            await self.db_service.save_search_history(
                query=query,
                result_count=result_count,
                user_id=st.session_state.get('user_id'),
                filters=st.session_state.get('filters', {})
            )
        except Exception as e:
            print(f"Error saving search history: {e}")
    
    def _render_search_results(self, results: List[Dict[str, Any]]):
        """Í≤ÄÏÉâ Í≤∞Í≥º Î†åÎçîÎßÅ"""
        if not results:
            st.info("No results found.")
            return
        
        st.markdown(f"#### Found {len(results)} results")
        
        for i, result in enumerate(results):
            with st.container():
                col_symbol, col_info, col_sentiment, col_actions = st.columns([1, 3, 1, 1])
                
                with col_symbol:
                    st.markdown(f"**{result['symbol']}**")
                
                with col_info:
                    st.markdown(f"{result['company_name']}")
                    st.markdown(f"{result['exchange']} ‚Ä¢ {result['sector']}")
                    
                    if result.get('current_price'):
                        price_color = "üü¢" if result.get('day_change', 0) >= 0 else "üî¥"
                        st.markdown(
                            f"{price_color} ${result['current_price']:.2f} "
                            f"({result.get('day_change_pct', 0):+.2f}%)"
                        )
                
                with col_sentiment:
                    if result.get('overall_sentiment') is not None:
                        sentiment_color = "üü¢" if result['overall_sentiment'] > 0.1 else "üî¥" if result['overall_sentiment'] < -0.1 else "‚ö™"
                        st.markdown(f"{sentiment_color} {result['overall_sentiment']:.2f}")
                    
                    if result.get('trending_status'):
                        st.markdown(f"üî• {result.get('trend_score', 0):.1f}")
                
                with col_actions:
                    if st.button("View", key=f"view_{i}"):
                        st.session_state.current_symbol = result['symbol']
                        st.rerun()
                    
                    if st.button("Add", key=f"add_{i}"):
                        asyncio.run(self._add_to_watchlist(result['symbol']))
                        st.success(f"{result['symbol']} added to watchlist!")
                
                st.divider()
    
    async def _add_to_watchlist(self, symbol: str):
        """Í¥ÄÏã¨Ï¢ÖÎ™©Ïóê Ï∂îÍ∞Ä"""
        try:
            user_id = st.session_state.get('user_id')
            if user_id:
                await self.db_service.add_to_watchlist(user_id, symbol)
            else:
                # Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóê Ï†ÄÏû• (ÏûÑÏãú)
                if 'watchlist' not in st.session_state:
                    st.session_state.watchlist = []
                if symbol not in st.session_state.watchlist:
                    st.session_state.watchlist.append(symbol)
        except Exception as e:
            st.error(f"Error adding to watchlist: {str(e)}")
```

### 5.2 Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑúÎπÑÏä§ Ïó∞Îèô

```python
# services/database_service.py
import asyncpg
from typing import List, Dict, Any, Optional, Tuple
from datetime import datetime

class DatabaseService:
    """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑúÎπÑÏä§"""
    
    def __init__(self):
        self.pool = None
    
    async def initialize(self, db_url: str):
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÌíÄ Ï¥àÍ∏∞Ìôî"""
        self.pool = await asyncpg.create_pool(
            db_url,
            min_size=5,
            max_size=20,
            command_timeout=60
        )
    
    async def search_stocks(self, query: str, filters: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Ï£ºÏãù Í≤ÄÏÉâ"""
        if not self.pool:
            raise Exception("Database pool not initialized")
        
        async with self.pool.acquire() as conn:
            try:
                # Í∏∞Î≥∏ ÏøºÎ¶¨
                base_query = """
                SELECT 
                    symbol, company_name, stock_type, exchange, sector, industry,
                    current_price, previous_close, day_change, day_change_pct,
                    volume, market_cap, overall_sentiment, mention_count_24h,
                    trending_status, trend_score, last_updated
                FROM unified_stocks_v2
                WHERE 
                    (symbol ILIKE $1 OR company_name ILIKE $1)
                """
                
                # ÌïÑÌÑ∞ Ï°∞Í±¥ Ï∂îÍ∞Ä
                params = [f"%{query}%"]
                param_count = 1
                
                if 'stock_type' in filters:
                    param_count += 1
                    base_query += f" AND stock_type = ${param_count}"
                    params.append(filters['stock_type'])
                
                if 'exchange' in filters:
                    param_count += 1
                    base_query += f" AND exchange = ${param_count}"
                    params.append(filters['exchange'])
                
                if 'sector' in filters:
                    param_count += 1
                    base_query += f" AND sector ILIKE ${param_count}"
                    params.append(f"%{filters['sector']}%")
                
                if 'price_range' in filters:
                    min_price, max_price = filters['price_range']
                    if min_price > 0:
                        param_count += 1
                        base_query += f" AND current_price >= ${param_count}"
                        params.append(min_price)
                    if max_price < 10000:
                        param_count += 1
                        base_query += f" AND current_price <= ${param_count}"
                        params.append(max_price)
                
                if 'min_sentiment' in filters:
                    param_count += 1
                    base_query += f" AND overall_sentiment >= ${param_count}"
                    params.append(filters['min_sentiment'])
                
                # Ï†ïÎ†¨ Ï°∞Í±¥
                base_query += " ORDER BY "
                
                # Ìä∏Î†åÎî© ÏÉÅÌÉú Ïö∞ÏÑ† Ï†ïÎ†¨
                base_query += "trending_status DESC, trend_score DESC, "
                
                # Í¥ÄÎ†®ÎèÑ Ï†ïÎ†¨ (Ïã¨Î≥º Ï†ïÌôï ÏùºÏπò > ÌöåÏÇ¨Î™Ö ÏùºÏπò)
                base_query += """
                CASE 
                    WHEN symbol ILIKE $1 THEN 1
                    WHEN company_name ILIKE $1 THEN 2
                    ELSE 3
                END ASC,
                day_change_pct DESC
                LIMIT 50
                """
                
                rows = await conn.fetch(base_query, *params)
                
                results = []
                for row in rows:
                    results.append({
                        'symbol': row['symbol'],
                        'company_name': row['company_name'],
                        'stock_type': row['stock_type'],
                        'exchange': row['exchange'],
                        'sector': row['sector'],
                        'industry': row['industry'],
                        'current_price': float(row['current_price']) if row['current_price'] else None,
                        'previous_close': float(row['previous_close']) if row['previous_close'] else None,
                        'day_change': float(row['day_change']) if row['day_change'] else None,
                        'day_change_pct': float(row['day_change_pct']) if row['day_change_pct'] else None,
                        'volume': row['volume'],
                        'market_cap': row['market_cap'],
                        'overall_sentiment': float(row['overall_sentiment']) if row['overall_sentiment'] else None,
                        'mention_count_24h': row['mention_count_24h'],
                        'trending_status': row['trending_status'],
                        'trend_score': float(row['trend_score']) if row['trend_score'] else None,
                        'last_updated': row['last_updated']
                    })
                
                return results
                
            except Exception as e:
                print(f"Database search error: {e}")
                raise
    
    async def save_search_history(self, query: str, result_count: int, 
                                 user_id: Optional[str] = None, 
                                 filters: Dict[str, Any] = None):
        """Í≤ÄÏÉâ Í∏∞Î°ù Ï†ÄÏû•"""
        if not self.pool:
            raise Exception("Database pool not initialized")
        
        async with self.pool.acquire() as conn:
            try:
                await conn.execute(
                    """
                    INSERT INTO search_history 
                    (user_id, search_query, result_count, filters, search_time)
                    VALUES ($1, $2, $3, $4, $5)
                    ON CONFLICT (user_id, search_query) 
                    DO UPDATE SET 
                        result_count = EXCLUDED.result_count,
                        filters = EXCLUDED.filters,
                        search_time = EXCLUDED.search_time,
                        search_count = search_history.search_count + 1
                    """,
                    user_id,
                    query,
                    result_count,
                    json.dumps(filters) if filters else None,
                    datetime.utcnow()
                )
            except Exception as e:
                print(f"Error saving search history: {e}")
                raise
    
    async def add_to_watchlist(self, user_id: str, symbol: str, category: str = "default"):
        """Í¥ÄÏã¨Ï¢ÖÎ™©Ïóê Ï∂îÍ∞Ä"""
        if not self.pool:
            raise Exception("Database pool not initialized")
        
        async with self.pool.acquire() as conn:
            try:
                await conn.execute(
                    """
                    INSERT INTO watchlists (user_id, symbol, category, added_date)
                    VALUES ($1, $2, $3, $4)
                    ON CONFLICT (user_id, symbol) DO NOTHING
                    """,
                    user_id,
                    symbol,
                    category,
                    datetime.utcnow()
                )
            except Exception as e:
                print(f"Error adding to watchlist: {e}")
                raise
    
    async def get_watchlist(self, user_id: str) -> List[Dict[str, Any]]:
        """Í¥ÄÏã¨Ï¢ÖÎ™© Ï°∞Ìöå"""
        if not self.pool:
            raise Exception("Database pool not initialized")
        
        async with self.pool.acquire() as conn:
            try:
                rows = await conn.fetch(
                    """
                    SELECT 
                        w.symbol, w.category, w.added_date,
                        s.company_name, s.current_price, s.previous_close,
                        s.day_change, s.day_change_pct, s.overall_sentiment,
                        s.mention_count_24h, s.trending_status
                    FROM watchlists w
                    JOIN unified_stocks_v2 s ON w.symbol = s.symbol
                    WHERE w.user_id = $1
                    ORDER BY w.added_date DESC
                    """,
                    user_id
                )
                
                results = []
                for row in rows:
                    results.append({
                        'symbol': row['symbol'],
                        'category': row['category'],
                        'added_date': row['added_date'],
                        'company_name': row['company_name'],
                        'current_price': float(row['current_price']) if row['current_price'] else None,
                        'previous_close': float(row['previous_close']) if row['previous_close'] else None,
                        'day_change': float(row['day_change']) if row['day_change'] else None,
                        'day_change_pct': float(row['day_change_pct']) if row['day_change_pct'] else None,
                        'overall_sentiment': float(row['overall_sentiment']) if row['overall_sentiment'] else None,
                        'mention_count_24h': row['mention_count_24h'],
                        'trending_status': row['trending_status']
                    })
                
                return results
                
            except Exception as e:
                print(f"Error getting watchlist: {e}")
                raise
```

## 6. Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Î∞è ÎèôÍ∏∞Ìôî Ï†ÑÎûµ

### 6.1 Î∂ÑÏÇ∞ Ìä∏ÎûúÏû≠ÏÖò Ï≤òÎ¶¨

```python
# services/transaction_service.py
import asyncpg
from typing import List, Dict, Any, Callable, Optional
from contextlib import asynccontextmanager
from datetime import datetime

class TransactionService:
    """Î∂ÑÏÇ∞ Ìä∏ÎûúÏû≠ÏÖò ÏÑúÎπÑÏä§"""
    
    def __init__(self, db_pool: asyncpg.Pool, redis_client):
        self.db_pool = db_pool
        self.redis = redis_client
    
    @asynccontextmanager
    async def transaction(self):
        """Ìä∏ÎûúÏû≠ÏÖò Ïª®ÌÖçÏä§Ìä∏ Îß§ÎãàÏ†Ä"""
        async with self.db_pool.acquire() as conn:
            async with conn.transaction():
                try:
                    yield conn
                except Exception as e:
                    # Ìä∏ÎûúÏû≠ÏÖò Î°§Î∞± Ïãú Ï∫êÏãú Î¨¥Ìö®Ìôî
                    await self._rollback_cache_changes()
                    raise e
    
    async def update_stock_with_sentiment(self, symbol: str, 
                                        price_data: Dict[str, Any],
                                        sentiment_data: Dict[str, Any]):
        """Ï£ºÏãùÍ≥º ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ ÎèôÏãú ÏóÖÎç∞Ïù¥Ìä∏"""
        async with self.transaction() as conn:
            try:
                # Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
                await conn.execute(
                    """
                    UPDATE unified_stocks_v2
                    SET 
                        current_price = $2,
                        previous_close = $3,
                        day_change = $4,
                        day_change_pct = $5,
                        volume = $6,
                        last_updated = CURRENT_TIMESTAMP
                    WHERE symbol = $1
                    """,
                    symbol,
                    price_data.get('current_price'),
                    price_data.get('previous_close'),
                    price_data.get('day_change'),
                    price_data.get('day_change_pct'),
                    price_data.get('volume')
                )
                
                # ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
                await conn.execute(
                    """
                    UPDATE unified_stocks_v2
                    SET 
                        overall_sentiment = $2,
                        mention_count_24h = $3,
                        trending_status = $4,
                        trend_score = $5,
                        last_updated = CURRENT_TIMESTAMP
                    WHERE symbol = $1
                    """,
                    symbol,
                    sentiment_data.get('overall_sentiment'),
                    sentiment_data.get('mention_count_24h'),
                    sentiment_data.get('trending_status'),
                    sentiment_data.get('trend_score')
                )
                
                # ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ Í∏∞Î°ù
                await conn.execute(
                    """
                    INSERT INTO stock_prices_timescale 
                    (time, symbol, close_price, volume)
                    VALUES (NOW(), $1, $2, $3)
                    """,
                    symbol,
                    price_data.get('current_price'),
                    price_data.get('volume')
                )
                
                await conn.execute(
                    """
                    INSERT INTO sentiment_timeseries_v2 
                    (time, symbol, sentiment_score, mention_count, source)
                    VALUES (NOW(), $1, $2, $3, $4)
                    """,
                    symbol,
                    sentiment_data.get('overall_sentiment'),
                    sentiment_data.get('mention_count_24h'),
                    'unified'
                )
                
                # Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏ (Ìä∏ÎûúÏû≠ÏÖò Ïª§Î∞ã ÌõÑ)
                await self._update_cache_after_commit(symbol, price_data, sentiment_data)
                
            except Exception as e:
                print(f"Error in update_stock_with_sentiment: {e}")
                raise
    
    async def _update_cache_after_commit(self, symbol: str, 
                                      price_data: Dict[str, Any],
                                      sentiment_data: Dict[str, Any]):
        """Ìä∏ÎûúÏû≠ÏÖò Ïª§Î∞ã ÌõÑ Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏"""
        try:
            # Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
            await self.redis.setex(
                f"stock:{symbol}",
                300,  # 5Î∂Ñ TTL
                json.dumps(price_data, default=str)
            )
            
            # ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
            await self.redis.setex(
                f"sentiment:{symbol}",
                300,  # 5Î∂Ñ TTL
                json.dumps(sentiment_data, default=str)
            )
            
            # Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º Î∞úÏÜ°
            await self._send_realtime_notification(symbol, price_data, sentiment_data)
            
        except Exception as e:
            print(f"Error updating cache after commit: {e}")
    
    async def _rollback_cache_changes(self):
        """Ìä∏ÎûúÏû≠ÏÖò Î°§Î∞± Ïãú Ï∫êÏãú Î≥ÄÍ≤Ω ÏÇ¨Ìï≠ Ï†ïÎ¶¨"""
        # Î°§Î∞± Ïãú ÏàòÌñâÌï† Ï∫êÏãú Ï†ïÎ¶¨ Î°úÏßÅ
        pass
    
    async def _send_realtime_notification(self, symbol: str, 
                                       price_data: Dict[str, Any],
                                       sentiment_data: Dict[str, Any]):
        """Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º Î∞úÏÜ°"""
        try:
            notification = {
                'type': 'stock_update',
                'symbol': symbol,
                'price_data': price_data,
                'sentiment_data': sentiment_data,
                'timestamp': datetime.utcnow().isoformat()
            }
            
            # Redis pub/subÏùÑ ÌÜµÌïú Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º
            await self.redis.publish('stock_updates', json.dumps(notification))
            
        except Exception as e:
            print(f"Error sending realtime notification: {e}")
```

### 6.2 Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù

```python
# services/consistency_service.py
import asyncpg
from typing import Dict, Any, List, Tuple
from datetime import datetime, timedelta

class ConsistencyService:
    """Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± ÏÑúÎπÑÏä§"""
    
    def __init__(self, db_pool: asyncpg.Pool):
        self.db_pool = db_pool
    
    async def check_data_consistency(self, symbol: str) -> Dict[str, Any]:
        """Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù"""
        async with self.db_pool.acquire() as conn:
            try:
                # ÌÜµÌï© ÌÖåÏù¥Î∏î Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
                unified_data = await conn.fetchrow(
                    """
                    SELECT 
                        symbol, current_price, previous_close, day_change,
                        overall_sentiment, mention_count_24h, last_updated
                    FROM unified_stocks_v2
                    WHERE symbol = $1
                    """,
                    symbol
                )
                
                if not unified_data:
                    return {'status': 'error', 'message': 'Symbol not found'}
                
                # ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ ÏµúÏã† Í∞í Ï°∞Ìöå
                latest_price = await conn.fetchrow(
                    """
                    SELECT time, close_price, volume
                    FROM stock_prices_timescale
                    WHERE symbol = $1
                    ORDER BY time DESC
                    LIMIT 1
                    """,
                    symbol
                )
                
                latest_sentiment = await conn.fetchrow(
                    """
                    SELECT time, sentiment_score, mention_count
                    FROM sentiment_timeseries_v2
                    WHERE symbol = $1
                    ORDER BY time DESC
                    LIMIT 1
                    """,
                    symbol
                )
                
                # ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù Í≤∞Í≥º
                consistency_issues = []
                
                # Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù
                if latest_price:
                    price_diff = abs(
                        (unified_data['current_price'] or 0) - 
                        (latest_price['close_price'] or 0)
                    )
                    if price_diff > 0.01:  # 0.01 Ïù¥ÏÉÅ Ï∞®Ïù¥
                        consistency_issues.append({
                            'type': 'price_mismatch',
                            'unified_value': unified_data['current_price'],
                            'timeseries_value': latest_price['close_price'],
                            'difference': price_diff
                        })
                
                # ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù
                if latest_sentiment:
                    sentiment_diff = abs(
                        (unified_data['overall_sentiment'] or 0) - 
                        (latest_sentiment['sentiment_score'] or 0)
                    )
                    if sentiment_diff > 0.1:  # 0.1 Ïù¥ÏÉÅ Ï∞®Ïù¥
                        consistency_issues.append({
                            'type': 'sentiment_mismatch',
                            'unified_value': unified_data['overall_sentiment'],
                            'timeseries_value': latest_sentiment['sentiment_score'],
                            'difference': sentiment_diff
                        })
                
                # Îç∞Ïù¥ÌÑ∞ ÏµúÏã†ÏÑ± Í≤ÄÏ¶ù
                now = datetime.utcnow()
                data_age = now - unified_data['last_updated']
                
                if data_age > timedelta(minutes=10):
                    consistency_issues.append({
                        'type': 'stale_data',
                        'last_updated': unified_data['last_updated'],
                        'age_minutes': data_age.total_seconds() / 60
                    })
                
                return {
                    'status': 'success',
                    'symbol': symbol,
                    'consistency_issues': consistency_issues,
                    'is_consistent': len(consistency_issues) == 0
                }
                
            except Exception as e:
                return {
                    'status': 'error',
                    'message': str(e)
                }
    
    async def fix_consistency_issues(self, symbol: str) -> Dict[str, Any]:
        """ÏùºÍ¥ÄÏÑ± Î¨∏Ï†ú ÏàòÏ†ï"""
        async with self.db_pool.acquire() as conn:
            try:
                # ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÏµúÏã† Í∞í Ï°∞Ìöå
                latest_price = await conn.fetchrow(
                    """
                    SELECT close_price, volume
                    FROM stock_prices_timescale
                    WHERE symbol = $1
                    ORDER BY time DESC
                    LIMIT 1
                    """,
                    symbol
                )
                
                latest_sentiment = await conn.fetchrow(
                    """
                    SELECT sentiment_score, mention_count
                    FROM sentiment_timeseries_v2
                    WHERE symbol = $1
                    ORDER BY time DESC
                    LIMIT 1
                    """,
                    symbol
                )
                
                # ÌÜµÌï© ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
                if latest_price:
                    await conn.execute(
                        """
                        UPDATE unified_stocks_v2
                        SET 
                            current_price = $2,
                            volume = $3,
                            last_updated = CURRENT_TIMESTAMP
                        WHERE symbol = $1
                        """,
                        symbol,
                        latest_price['close_price'],
                        latest_price['volume']
                    )
                
                if latest_sentiment:
                    await conn.execute(
                        """
                        UPDATE unified_stocks_v2
                        SET 
                            overall_sentiment = $2,
                            mention_count_24h = $3,
                            last_updated = CURRENT_TIMESTAMP
                        WHERE symbol = $1
                        """,
                        symbol,
                        latest_sentiment['sentiment_score'],
                        latest_sentiment['mention_count']
                    )
                
                return {
                    'status': 'success',
                    'message': f'Consistency issues fixed for {symbol}'
                }
                
            except Exception as e:
                return {
                    'status': 'error',
                    'message': str(e)
                }
    
    async def get_consistency_report(self) -> Dict[str, Any]:
        """Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Î≥¥Í≥†ÏÑú"""
        async with self.db_pool.acquire() as conn:
            try:
                # Ï†ÑÏ≤¥ Ïã¨Î≥º Î™©Î°ù Ï°∞Ìöå
                symbols = await conn.fetch(
                    "SELECT symbol FROM unified_stocks_v2 LIMIT 100"
                )
                
                total_symbols = len(symbols)
                consistent_symbols = 0
                issues_summary = {}
                
                for symbol_row in symbols:
                    symbol = symbol_row['symbol']
                    consistency_result = await self.check_data_consistency(symbol)
                    
                    if consistency_result['status'] == 'success':
                        if consistency_result['is_consistent']:
                            consistent_symbols += 1
                        else:
                            for issue in consistency_result['consistency_issues']:
                                issue_type = issue['type']
                                if issue_type not in issues_summary:
                                    issues_summary[issue_type] = 0
                                issues_summary[issue_type] += 1
                
                consistency_rate = (consistent_symbols / total_symbols) * 100 if total_symbols > 0 else 0
                
                return {
                    'total_symbols_checked': total_symbols,
                    'consistent_symbols': consistent_symbols,
                    'consistency_rate': consistency_rate,
                    'issues_summary': issues_summary,
                    'timestamp': datetime.utcnow().isoformat()
                }
                
            except Exception as e:
                return {
                    'status': 'error',
                    'message': str(e)
                }
```

## 7. ÏµúÏ¢Ö Í≤ÄÌÜ† Í≤∞Í≥º Î∞è Í∂åÏû•ÏÇ¨Ìï≠

### 7.1 Ï£ºÏöî Î∞úÍ≤¨ ÏÇ¨Ìï≠

1. **Îç∞Ïù¥ÌÑ∞ Î™®Îç∏ Ï§ëÎ≥µ Î¨∏Ï†ú**: unified_stocks ÌÖåÏù¥Î∏îÍ≥º Í∞úÎ≥Ñ ÌÖåÏù¥Î∏î Í∞Ñ Îç∞Ïù¥ÌÑ∞ Ï§ëÎ≥µ Î∞úÏÉù
2. **Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî Î∂ÄÏ°±**: UI ÏóòÎ¶¨Î®ºÌä∏ÏôÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í∞Ñ Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞Ìôî Ï†ÑÎûµ Î∂ÄÏû¨
3. **Ìä∏ÎûúÏû≠ÏÖò Ï≤òÎ¶¨ ÎØ∏Ìù°**: Î∂ÑÏÇ∞ ÌôòÍ≤ΩÏóêÏÑúÏùò Ìä∏ÎûúÏû≠ÏÖò Ï≤òÎ¶¨ Î°úÏßÅ Î∂ÄÏ°±
4. **Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù Î∂ÄÏ°±**: Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù Î∞è ÏàòÏ†ï Î©îÏª§ÎãàÏ¶ò Î∂ÄÏû¨

### 7.2 Íµ¨Ï≤¥Ï†ÅÏù∏ Í∞úÏÑ† Í∂åÏû•ÏÇ¨Ìï≠

#### 7.2.1 Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà Í∞úÏÑ† (Ï¶âÏãú Ïã§Ìñâ)

**Ïã§Ìñâ Í≥ÑÌöç**:
```sql
-- 1. unified_stocks_v2 ÌÖåÏù¥Î∏î ÏÉùÏÑ± Î∞è Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
CREATE TABLE unified_stocks_v2 AS
SELECT * FROM unified_stocks WHERE 1=0;

-- 2. Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïä§ÌÅ¨Î¶ΩÌä∏
INSERT INTO unified_stocks_v2 (
    symbol, company_name, stock_type, exchange, sector, industry,
    current_price, previous_close, day_change, day_change_pct,
    volume, market_cap, overall_sentiment, mention_count_24h,
    trending_status, trend_score, last_updated
)
SELECT
    s.symbol, s.company_name, s.stock_type, s.exchange, s.sector, s.industry,
    sp.close_price as current_price,
    LAG(sp.close_price) OVER (PARTITION BY s.symbol ORDER BY sp.time DESC) as previous_close,
    sp.close_price - LAG(sp.close_price) OVER (PARTITION BY s.symbol ORDER BY sp.time DESC) as day_change,
    CASE
        WHEN LAG(sp.close_price) OVER (PARTITION BY s.symbol ORDER BY sp.time DESC) > 0
        THEN ((sp.close_price - LAG(sp.close_price) OVER (PARTITION BY s.symbol ORDER BY sp.time DESC)) /
              LAG(sp.close_price) OVER (PARTITION BY s.symbol ORDER BY sp.time DESC)) * 100
        ELSE 0
    END as day_change_pct,
    sp.volume, s.market_cap, st.sentiment_score as overall_sentiment,
    COUNT(sm.id) as mention_count_24h,
    CASE WHEN COUNT(sm.id) > 10 THEN true ELSE false END as trending_status,
    (COUNT(sm.id) * 0.3 + st.sentiment_score * 0.7) as trend_score,
    NOW() as last_updated
FROM stocks s
LEFT JOIN (
    SELECT DISTINCT ON (symbol) symbol, close_price, volume, time
    FROM stock_prices
    ORDER BY symbol, time DESC
) sp ON s.symbol = sp.symbol
LEFT JOIN (
    SELECT DISTINCT ON (symbol) symbol, sentiment_score, time
    FROM sentiment_timeseries
    ORDER BY symbol, time DESC
) st ON s.symbol = st.symbol
LEFT JOIN stock_mentions sm ON s.symbol = sm.symbol
    AND sm.timestamp > NOW() - INTERVAL '24 hours'
GROUP BY s.symbol, s.company_name, s.stock_type, s.exchange, s.sector, s.industry,
         sp.close_price, sp.volume, st.sentiment_score;
```

**Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî**:
```sql
-- Í≤ÄÏÉâ ÏÑ±Îä•ÏùÑ ÏúÑÌïú Ïù∏Îç±Ïä§
CREATE INDEX idx_unified_stocks_v2_symbol_company ON unified_stocks_v2(symbol, company_name);
CREATE INDEX idx_unified_stocks_v2_sector_exchange ON unified_stocks_v2(sector, exchange);
CREATE INDEX idx_unified_stocks_v2_trending_score ON unified_stocks_v2(trending_status DESC, trend_score DESC);
CREATE INDEX idx_unified_stocks_v2_price_range ON unified_stocks_v2(current_price) WHERE current_price IS NOT NULL;
CREATE INDEX idx_unified_stocks_v2_sentiment ON unified_stocks_v2(overall_sentiment DESC) WHERE overall_sentiment IS NOT NULL;
```

#### 7.2.2 Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ïó∞Îèô Í∞ïÌôî (2Ï£º ÎÇ¥ ÏôÑÎ£å)

**WebSocket ÏÑúÎ≤Ñ Íµ¨ÌòÑ**:
```python
# Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏÑúÎ≤Ñ Íµ¨ÌòÑ (main.py)
import asyncio
import websockets
import json
from services.real_time_data_sync import RealTimeDataSync

async def websocket_server(websocket, path):
    """WebSocket ÏÑúÎ≤Ñ Ìï∏Îì§Îü¨"""
    data_sync = st.session_state.get('data_sync')
    if not data_sync:
        return
    
    await data_sync.register_client(websocket)
    
    try:
        async for message in websocket:
            data = json.loads(message)
            
            if data['type'] == 'subscribe':
                await data_sync.subscribe_symbol(websocket, data['symbol'])
            elif data['type'] == 'unsubscribe':
                await data_sync.unsubscribe_symbol(websocket, data['symbol'])
                
    except websockets.exceptions.ConnectionClosed:
        pass
    finally:
        await data_sync.unregister_client(websocket)

# WebSocket ÏÑúÎ≤Ñ ÏãúÏûë
async def start_websocket_server():
    server = await websockets.serve(websocket_server, "localhost", 8765)
    await server.wait_closed()

# Î≥ÑÎèÑ Ïä§Î†àÎìúÏóêÏÑú WebSocket ÏÑúÎ≤Ñ Ïã§Ìñâ
import threading
websocket_thread = threading.Thread(target=lambda: asyncio.run(start_websocket_server()))
websocket_thread.daemon = True
websocket_thread.start()
```

**StreamlitÍ≥º WebSocket Ïó∞Îèô**:
```python
# StreamlitÏóêÏÑú Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏàòÏã†
import streamlit as st
import json
import asyncio
import websockets
from typing import Dict, Any

class StreamlitWebSocketClient:
    """Streamlit WebSocket ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏"""
    
    def __init__(self, uri: str = "ws://localhost:8765"):
        self.uri = uri
        self.websocket = None
        self.subscribed_symbols = set()
        self.real_time_data = {}
    
    async def connect(self):
        """WebSocket ÏÑúÎ≤Ñ Ïó∞Í≤∞"""
        try:
            self.websocket = await websockets.connect(self.uri)
            return True
        except Exception as e:
            print(f"WebSocket Ïó∞Í≤∞ Ïã§Ìå®: {e}")
            return False
    
    async def subscribe_symbol(self, symbol: str):
        """Ïã¨Î≥º Íµ¨ÎèÖ"""
        if self.websocket and symbol not in self.subscribed_symbols:
            await self.websocket.send(json.dumps({
                'type': 'subscribe',
                'symbol': symbol
            }))
            self.subscribed_symbols.add(symbol)
    
    async def listen_for_updates(self):
        """Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏàòÏã†"""
        if not self.websocket:
            return
        
        try:
            async for message in self.websocket:
                data = json.loads(message)
                
                if data['type'] == 'stock_data':
                    symbol = data['symbol']
                    self.real_time_data[symbol] = data['data']
                    
                    # Streamlit ÏÑ∏ÏÖò ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                    if f"real_time_{symbol}" not in st.session_state:
                        st.session_state[f"real_time_{symbol}"] = {}
                    
                    st.session_state[f"real_time_{symbol}"] = data['data']
                    
                    # UI Í∞ïÏ†ú ÏóÖÎç∞Ïù¥Ìä∏
                    st.rerun()
                    
        except websockets.exceptions.ConnectionClosed:
            print("WebSocket Ïó∞Í≤∞Ïù¥ Ï¢ÖÎ£åÎê®")
        except Exception as e:
            print(f"Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏàòÏã† Ïò§Î•ò: {e}")
    
    def get_real_time_data(self, symbol: str) -> Dict[str, Any]:
        """Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        return self.real_time_data.get(symbol, {})

# Streamlit Ïï±ÏóêÏÑú ÏÇ¨Ïö©
@st.cache_resource
def get_websocket_client():
    """WebSocket ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§ Í∞ÄÏ†∏Ïò§Í∏∞"""
    client = StreamlitWebSocketClient()
    return client

# Ïï± Ï¥àÍ∏∞Ìôî Ïãú WebSocket Ïó∞Í≤∞
if 'ws_client' not in st.session_state:
    st.session_state.ws_client = get_websocket_client()
    
    # ÎπÑÎèôÍ∏∞ Ïó∞Í≤∞ ÏãúÏûë
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    
    if loop.run_until_complete(st.session_state.ws_client.connect()):
        # Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏàòÏã† ÏãúÏûë
        threading.Thread(
            target=lambda: loop.run_until_complete(
                st.session_state.ws_client.listen_for_updates()
            ),
            daemon=True
        ).start()
```

#### 7.2.3 Ìä∏ÎûúÏû≠ÏÖò Í¥ÄÎ¶¨ Í∞ïÌôî (3Ï£º ÎÇ¥ ÏôÑÎ£å)

**Î∂ÑÏÇ∞ Ìä∏ÎûúÏû≠ÏÖò ÏÑúÎπÑÏä§ Íµ¨ÌòÑ**:
```python
# services/distributed_transaction_service.py
import asyncpg
import redis
from typing import Dict, Any, List, Optional, Callable
from contextlib import asynccontextmanager
from datetime import datetime
import json
import uuid

class DistributedTransactionService:
    """Î∂ÑÏÇ∞ Ìä∏ÎûúÏû≠ÏÖò ÏÑúÎπÑÏä§"""
    
    def __init__(self, db_pool: asyncpg.Pool, redis_client: redis.Redis):
        self.db_pool = db_pool
        self.redis = redis_client
        self.transaction_timeout = 30  # 30Ï¥à ÌÉÄÏûÑÏïÑÏõÉ
    
    @asynccontextmanager
    async def distributed_transaction(self, transaction_id: Optional[str] = None):
        """Î∂ÑÏÇ∞ Ìä∏ÎûúÏû≠ÏÖò Ïª®ÌÖçÏä§Ìä∏ Îß§ÎãàÏ†Ä"""
        if not transaction_id:
            transaction_id = str(uuid.uuid4())
        
        # Ìä∏ÎûúÏû≠ÏÖò ÏÉÅÌÉú Ï†ÄÏû•
        await self.redis.setex(
            f"tx:{transaction_id}",
            self.transaction_timeout,
            json.dumps({
                'status': 'started',
                'start_time': datetime.utcnow().isoformat(),
                'operations': []
            })
        )
        
        async with self.db_pool.acquire() as conn:
            async with conn.transaction():
                try:
                    yield conn, transaction_id
                    
                    # Ìä∏ÎûúÏû≠ÏÖò ÏÑ±Í≥µ Ïãú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                    await self.redis.setex(
                        f"tx:{transaction_id}",
                        self.transaction_timeout,
                        json.dumps({
                            'status': 'committed',
                            'commit_time': datetime.utcnow().isoformat()
                        })
                    )
                    
                except Exception as e:
                    # Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå® Ïãú ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                    await self.redis.setex(
                        f"tx:{transaction_id}",
                        self.transaction_timeout,
                        json.dumps({
                            'status': 'rolled_back',
                            'error': str(e),
                            'rollback_time': datetime.utcnow().isoformat()
                        })
                    )
                    raise e
    
    async def update_stock_with_sentiment(self, symbol: str,
                                        price_data: Dict[str, Any],
                                        sentiment_data: Dict[str, Any]) -> str:
        """Ï£ºÏãùÍ≥º ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ ÎèôÏãú ÏóÖÎç∞Ïù¥Ìä∏ (Î∂ÑÏÇ∞ Ìä∏ÎûúÏû≠ÏÖò)"""
        transaction_id = str(uuid.uuid4())
        
        async with self.distributed_transaction(transaction_id) as (conn, tx_id):
            # 1. Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
            await conn.execute(
                """
                UPDATE unified_stocks_v2
                SET
                    current_price = $2,
                    previous_close = $3,
                    day_change = $4,
                    day_change_pct = $5,
                    volume = $6,
                    last_updated = CURRENT_TIMESTAMP
                WHERE symbol = $1
                """,
                symbol,
                price_data.get('current_price'),
                price_data.get('previous_close'),
                price_data.get('day_change'),
                price_data.get('day_change_pct'),
                price_data.get('volume')
            )
            
            # Ìä∏ÎûúÏû≠ÏÖò Î°úÍ∑∏ Í∏∞Î°ù
            await self._log_operation(tx_id, 'update_stock_price', {
                'symbol': symbol,
                'price_data': price_data
            })
            
            # 2. ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏
            await conn.execute(
                """
                UPDATE unified_stocks_v2
                SET
                    overall_sentiment = $2,
                    mention_count_24h = $3,
                    trending_status = $4,
                    trend_score = $5,
                    last_updated = CURRENT_TIMESTAMP
                WHERE symbol = $1
                """,
                symbol,
                sentiment_data.get('overall_sentiment'),
                sentiment_data.get('mention_count_24h'),
                sentiment_data.get('trending_status'),
                sentiment_data.get('trend_score')
            )
            
            # Ìä∏ÎûúÏû≠ÏÖò Î°úÍ∑∏ Í∏∞Î°ù
            await self._log_operation(tx_id, 'update_sentiment', {
                'symbol': symbol,
                'sentiment_data': sentiment_data
            })
            
            # 3. ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ Í∏∞Î°ù
            await conn.execute(
                """
                INSERT INTO stock_prices_timescale
                (time, symbol, close_price, volume)
                VALUES (NOW(), $1, $2, $3)
                """,
                symbol,
                price_data.get('current_price'),
                price_data.get('volume')
            )
            
            await conn.execute(
                """
                INSERT INTO sentiment_timeseries_v2
                (time, symbol, sentiment_score, mention_count, source)
                VALUES (NOW(), $1, $2, $3, $4)
                """,
                symbol,
                sentiment_data.get('overall_sentiment'),
                sentiment_data.get('mention_count_24h'),
                'unified_update'
            )
            
            # Ìä∏ÎûúÏû≠ÏÖò Î°úÍ∑∏ Í∏∞Î°ù
            await self._log_operation(tx_id, 'insert_timeseries', {
                'symbol': symbol,
                'price': price_data.get('current_price'),
                'sentiment': sentiment_data.get('overall_sentiment')
            })
            
            # 4. Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏ (Ìä∏ÎûúÏû≠ÏÖò Ïª§Î∞ã ÌõÑ)
            await self._update_cache_after_commit(symbol, price_data, sentiment_data)
            
            # 5. Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º Î∞úÏÜ°
            await self._send_realtime_notification(symbol, price_data, sentiment_data)
        
        return transaction_id
    
    async def _log_operation(self, transaction_id: str, operation: str, data: Dict[str, Any]):
        """Ìä∏ÎûúÏû≠ÏÖò ÏûëÏóÖ Î°úÍ∑∏ Í∏∞Î°ù"""
        try:
            # RedisÏóê Ìä∏ÎûúÏû≠ÏÖò ÏûëÏóÖ Î°úÍ∑∏ Ï†ÄÏû•
            tx_key = f"tx:{transaction_id}"
            tx_data = await self.redis.get(tx_key)
            
            if tx_data:
                tx_info = json.loads(tx_data)
                tx_info['operations'].append({
                    'operation': operation,
                    'data': data,
                    'timestamp': datetime.utcnow().isoformat()
                })
                
                await self.redis.setex(tx_key, self.transaction_timeout, json.dumps(tx_info))
        except Exception as e:
            print(f"Ìä∏ÎûúÏû≠ÏÖò Î°úÍ∑∏ Í∏∞Î°ù Ïò§Î•ò: {e}")
    
    async def _update_cache_after_commit(self, symbol: str,
                                       price_data: Dict[str, Any],
                                       sentiment_data: Dict[str, Any]):
        """Ìä∏ÎûúÏû≠ÏÖò Ïª§Î∞ã ÌõÑ Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏"""
        try:
            # Ï£ºÏãù Îç∞Ïù¥ÌÑ∞ Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
            await self.redis.setex(
                f"stock:{symbol}",
                300,  # 5Î∂Ñ TTL
                json.dumps(price_data, default=str)
            )
            
            # ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏
            await self.redis.setex(
                f"sentiment:{symbol}",
                300,  # 5Î∂Ñ TTL
                json.dumps(sentiment_data, default=str)
            )
        except Exception as e:
            print(f"Ï∫êÏãú ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò: {e}")
    
    async def _send_realtime_notification(self, symbol: str,
                                        price_data: Dict[str, Any],
                                        sentiment_data: Dict[str, Any]):
        """Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º Î∞úÏÜ°"""
        try:
            notification = {
                'type': 'stock_update',
                'symbol': symbol,
                'price_data': price_data,
                'sentiment_data': sentiment_data,
                'timestamp': datetime.utcnow().isoformat()
            }
            
            # Redis pub/subÏùÑ ÌÜµÌïú Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º
            await self.redis.publish('stock_updates', json.dumps(notification))
            
        except Exception as e:
            print(f"Ïã§ÏãúÍ∞Ñ ÏïåÎ¶º Î∞úÏÜ° Ïò§Î•ò: {e}")
    
    async def get_transaction_status(self, transaction_id: str) -> Dict[str, Any]:
        """Ìä∏ÎûúÏû≠ÏÖò ÏÉÅÌÉú Ï°∞Ìöå"""
        try:
            tx_data = await self.redis.get(f"tx:{transaction_id}")
            if tx_data:
                return json.loads(tx_data)
            else:
                return {'status': 'not_found'}
        except Exception as e:
            return {'status': 'error', 'error': str(e)}
```

#### 7.2.4 Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù ÏãúÏä§ÌÖú (4Ï£º ÎÇ¥ ÏôÑÎ£å)

**ÏûêÎèô ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù ÏÑúÎπÑÏä§**:
```python
# services/automated_consistency_service.py
import asyncio
import asyncpg
from typing import Dict, Any, List
from datetime import datetime, timedelta
import json

class AutomatedConsistencyService:
    """ÏûêÎèô Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù ÏÑúÎπÑÏä§"""
    
    def __init__(self, db_pool: asyncpg.Pool, redis_client):
        self.db_pool = db_pool
        self.redis = redis_client
        self.check_interval = 300  # 5Î∂Ñ Í∞ÑÍ≤¨ Í≤ÄÏ¶ù
        self.is_running = False
    
    async def start_automated_checks(self):
        """ÏûêÎèô Í≤ÄÏ¶ù ÏãúÏûë"""
        self.is_running = True
        
        while self.is_running:
            try:
                # Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù
                await self.run_full_consistency_check()
                
                # Í≤ÄÏ¶ù Í≤∞Í≥º Ï∫êÏãúÏóê Ï†ÄÏû•
                await self.cache_consistency_results()
                
                # Îã§Ïùå Í≤ÄÏ¶ùÍπåÏßÄ ÎåÄÍ∏∞
                await asyncio.sleep(self.check_interval)
                
            except Exception as e:
                print(f"ÏûêÎèô ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù Ïò§Î•ò: {e}")
                await asyncio.sleep(60)  # Ïò§Î•ò Ïãú 1Î∂Ñ ÌõÑ Ïû¨ÏãúÎèÑ
    
    async def stop_automated_checks(self):
        """ÏûêÎèô Í≤ÄÏ¶ù Ï§ëÏßÄ"""
        self.is_running = False
    
    async def run_full_consistency_check(self) -> Dict[str, Any]:
        """Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù Ïã§Ìñâ"""
        async with self.db_pool.acquire() as conn:
            try:
                # 1. Ï†ÑÏ≤¥ Ïã¨Î≥º Î™©Î°ù Ï°∞Ìöå
                symbols = await conn.fetch(
                    "SELECT symbol FROM unified_stocks_v2 LIMIT 500"
                )
                
                total_symbols = len(symbols)
                consistent_symbols = 0
                issues_summary = {}
                critical_issues = []
                
                for symbol_row in symbols:
                    symbol = symbol_row['symbol']
                    
                    # Í∞úÎ≥Ñ Ïã¨Î≥º ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù
                    consistency_result = await self.check_symbol_consistency(conn, symbol)
                    
                    if consistency_result['status'] == 'success':
                        if consistency_result['is_consistent']:
                            consistent_symbols += 1
                        else:
                            # Ïù¥Ïäà Ïú†ÌòïÎ≥Ñ ÏßëÍ≥Ñ
                            for issue in consistency_result['consistency_issues']:
                                issue_type = issue['type']
                                if issue_type not in issues_summary:
                                    issues_summary[issue_type] = 0
                                issues_summary[issue_type] += 1
                                
                                # Ï§ëÏöî Ïù¥Ïäà ÏãùÎ≥Ñ
                                if issue_type in ['price_mismatch', 'sentiment_mismatch']:
                                    critical_issues.append({
                                        'symbol': symbol,
                                        'issue': issue
                                    })
                    
                    # Ïã¨Î≥ºÎ≥Ñ ÏùºÍ¥ÄÏÑ± ÏÉÅÌÉú Ï∫êÏãúÏóê Ï†ÄÏû•
                    await self.redis.setex(
                        f"consistency:{symbol}",
                        3600,  # 1ÏãúÍ∞Ñ TTL
                        json.dumps(consistency_result)
                    )
                
                consistency_rate = (consistent_symbols / total_symbols) * 100 if total_symbols > 0 else 0
                
                # Ï†ÑÏ≤¥ Í≤ÄÏ¶ù Í≤∞Í≥º
                result = {
                    'timestamp': datetime.utcnow().isoformat(),
                    'total_symbols_checked': total_symbols,
                    'consistent_symbols': consistent_symbols,
                    'consistency_rate': consistency_rate,
                    'issues_summary': issues_summary,
                    'critical_issues_count': len(critical_issues),
                    'critical_issues': critical_issues[:10]  # ÏÉÅÏúÑ 10Í∞úÎßå Ï†ÄÏû•
                }
                
                # ÏûêÎèô ÏàòÏ†ï ÏãúÎèÑ (Ï§ëÏöî Ïù¥ÏäàÏóê ÎåÄÌï¥ÏÑúÎßå)
                if len(critical_issues) > 0:
                    await self.auto_fix_critical_issues(critical_issues[:5])  # ÏÉÅÏúÑ 5Í∞úÎßå ÏàòÏ†ï
                
                return result
                
            except Exception as e:
                return {
                    'status': 'error',
                    'message': str(e),
                    'timestamp': datetime.utcnow().isoformat()
                }
    
    async def check_symbol_consistency(self, conn: asyncpg.Connection, symbol: str) -> Dict[str, Any]:
        """Í∞úÎ≥Ñ Ïã¨Î≥º ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù"""
        try:
            # ÌÜµÌï© ÌÖåÏù¥Î∏î Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
            unified_data = await conn.fetchrow(
                """
                SELECT
                    symbol, current_price, previous_close, day_change,
                    overall_sentiment, mention_count_24h, last_updated
                FROM unified_stocks_v2
                WHERE symbol = $1
                """,
                symbol
            )
            
            if not unified_data:
                return {'status': 'error', 'message': 'Symbol not found'}
            
            # ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ ÏµúÏã† Í∞í Ï°∞Ìöå
            latest_price = await conn.fetchrow(
                """
                SELECT time, close_price, volume
                FROM stock_prices_timescale
                WHERE symbol = $1
                ORDER BY time DESC
                LIMIT 1
                """,
                symbol
            )
            
            latest_sentiment = await conn.fetchrow(
                """
                SELECT time, sentiment_score, mention_count
                FROM sentiment_timeseries_v2
                WHERE symbol = $1
                ORDER BY time DESC
                LIMIT 1
                """,
                symbol
            )
            
            # ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù Í≤∞Í≥º
            consistency_issues = []
            
            # Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù
            if latest_price:
                price_diff = abs(
                    (unified_data['current_price'] or 0) -
                    (latest_price['close_price'] or 0)
                )
                if price_diff > 0.01:  # 0.01 Ïù¥ÏÉÅ Ï∞®Ïù¥
                    consistency_issues.append({
                        'type': 'price_mismatch',
                        'unified_value': float(unified_data['current_price']) if unified_data['current_price'] else None,
                        'timeseries_value': float(latest_price['close_price']) if latest_price['close_price'] else None,
                        'difference': float(price_diff)
                    })
            
            # ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù
            if latest_sentiment:
                sentiment_diff = abs(
                    (unified_data['overall_sentiment'] or 0) -
                    (latest_sentiment['sentiment_score'] or 0)
                )
                if sentiment_diff > 0.1:  # 0.1 Ïù¥ÏÉÅ Ï∞®Ïù¥
                    consistency_issues.append({
                        'type': 'sentiment_mismatch',
                        'unified_value': float(unified_data['overall_sentiment']) if unified_data['overall_sentiment'] else None,
                        'timeseries_value': float(latest_sentiment['sentiment_score']) if latest_sentiment['sentiment_score'] else None,
                        'difference': float(sentiment_diff)
                    })
            
            # Îç∞Ïù¥ÌÑ∞ ÏµúÏã†ÏÑ± Í≤ÄÏ¶ù
            now = datetime.utcnow()
            data_age = now - unified_data['last_updated']
            
            if data_age > timedelta(minutes=15):
                consistency_issues.append({
                    'type': 'stale_data',
                    'last_updated': unified_data['last_updated'].isoformat(),
                    'age_minutes': data_age.total_seconds() / 60
                })
            
            return {
                'status': 'success',
                'symbol': symbol,
                'consistency_issues': consistency_issues,
                'is_consistent': len(consistency_issues) == 0,
                'last_checked': now.isoformat()
            }
            
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e),
                'symbol': symbol
            }
    
    async def auto_fix_critical_issues(self, critical_issues: List[Dict[str, Any]]):
        """Ï§ëÏöî ÏùºÍ¥ÄÏÑ± Î¨∏Ï†ú ÏûêÎèô ÏàòÏ†ï"""
        async with self.db_pool.acquire() as conn:
            try:
                for issue_info in critical_issues:
                    symbol = issue_info['symbol']
                    issue = issue_info['issue']
                    
                    if issue['type'] == 'price_mismatch':
                        # ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÏµúÏã† Í∞ÄÍ≤©ÏúºÎ°ú ÌÜµÌï© ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
                        latest_price = await conn.fetchrow(
                            """
                            SELECT close_price, volume
                            FROM stock_prices_timescale
                            WHERE symbol = $1
                            ORDER BY time DESC
                            LIMIT 1
                            """,
                            symbol
                        )
                        
                        if latest_price:
                            await conn.execute(
                                """
                                UPDATE unified_stocks_v2
                                SET
                                    current_price = $2,
                                    volume = $3,
                                    last_updated = CURRENT_TIMESTAMP
                                WHERE symbol = $1
                                """,
                                symbol,
                                latest_price['close_price'],
                                latest_price['volume']
                            )
                            
                            print(f"ÏûêÎèô ÏàòÏ†ï ÏôÑÎ£å: {symbol} Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞")
                    
                    elif issue['type'] == 'sentiment_mismatch':
                        # ÏãúÍ≥ÑÏó¥ Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÏµúÏã† ÏÑºÌã∞Î®ºÌä∏Î°ú ÌÜµÌï© ÌÖåÏù¥Î∏î ÏóÖÎç∞Ïù¥Ìä∏
                        latest_sentiment = await conn.fetchrow(
                            """
                            SELECT sentiment_score, mention_count
                            FROM sentiment_timeseries_v2
                            WHERE symbol = $1
                            ORDER BY time DESC
                            LIMIT 1
                            """,
                            symbol
                        )
                        
                        if latest_sentiment:
                            await conn.execute(
                                """
                                UPDATE unified_stocks_v2
                                SET
                                    overall_sentiment = $2,
                                    mention_count_24h = $3,
                                    last_updated = CURRENT_TIMESTAMP
                                WHERE symbol = $1
                                """,
                                symbol,
                                latest_sentiment['sentiment_score'],
                                latest_sentiment['mention_count']
                            )
                            
                            print(f"ÏûêÎèô ÏàòÏ†ï ÏôÑÎ£å: {symbol} ÏÑºÌã∞Î®ºÌä∏ Îç∞Ïù¥ÌÑ∞")
                
            except Exception as e:
                print(f"ÏûêÎèô ÏàòÏ†ï Ïò§Î•ò: {e}")
    
    async def cache_consistency_results(self):
        """ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù Í≤∞Í≥º Ï∫êÏã±"""
        try:
            # ÏµúÏã† Í≤ÄÏ¶ù Í≤∞Í≥º Ï°∞Ìöå
            latest_result = await self.run_full_consistency_check()
            
            # RedisÏóê Í≤∞Í≥º Ï†ÄÏû•
            await self.redis.setex(
                "consistency_report",
                3600,  # 1ÏãúÍ∞Ñ TTL
                json.dumps(latest_result)
            )
            
            # ÏïåÎ¶º Î∞úÏÜ° (ÏùºÍ¥ÄÏÑ±Î•†Ïù¥ 90% ÎØ∏ÎßåÏù∏ Í≤ΩÏö∞)
            if latest_result.get('consistency_rate', 100) < 90:
                await self.send_consistency_alert(latest_result)
                
        except Exception as e:
            print(f"ÏùºÍ¥ÄÏÑ± Í≤∞Í≥º Ï∫êÏã± Ïò§Î•ò: {e}")
    
    async def send_consistency_alert(self, result: Dict[str, Any]):
        """ÏùºÍ¥ÄÏÑ± Í≤ΩÍ≥† ÏïåÎ¶º Î∞úÏÜ°"""
        try:
            alert = {
                'type': 'consistency_alert',
                'timestamp': datetime.utcnow().isoformat(),
                'consistency_rate': result.get('consistency_rate', 0),
                'critical_issues_count': result.get('critical_issues_count', 0),
                'message': f"Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ±Î•†Ïù¥ {result.get('consistency_rate', 0):.1f}%Î°ú Í∏∞Ï§ÄÏπò ÎØ∏Îã¨ÏûÖÎãàÎã§."
            }
            
            # Redis pub/subÏùÑ ÌÜµÌïú ÏïåÎ¶º Î∞úÏÜ°
            await self.redis.publish('system_alerts', json.dumps(alert))
            
        except Exception as e:
            print(f"ÏùºÍ¥ÄÏÑ± Í≤ΩÍ≥† Î∞úÏÜ° Ïò§Î•ò: {e}")
```

### 7.3 Íµ¨ÌòÑ Î°úÎìúÎßµ Î∞è ÏùºÏ†ï

#### Phase 1: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà Í∞úÏÑ† (1-2Ï£º)
- **1Ï£ºÏ∞®**: unified_stocks_v2 ÌÖåÏù¥Î∏î ÏÉùÏÑ± Î∞è Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò
- **2Ï£ºÏ∞®**: Ïù∏Îç±Ïä§ ÏµúÏ†ÅÌôî Î∞è ÏÑ±Îä• ÌÖåÏä§Ìä∏

#### Phase 2: Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ Ïó∞Îèô (2-3Ï£º)
- **2Ï£ºÏ∞®**: WebSocket ÏÑúÎ≤Ñ Íµ¨ÌòÑ
- **3Ï£ºÏ∞®**: StreamlitÍ≥º WebSocket Ïó∞Îèô Î∞è ÌÖåÏä§Ìä∏

#### Phase 3: Ìä∏ÎûúÏû≠ÏÖò Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú (3-4Ï£º)
- **3Ï£ºÏ∞®**: Î∂ÑÏÇ∞ Ìä∏ÎûúÏû≠ÏÖò ÏÑúÎπÑÏä§ Íµ¨ÌòÑ
- **4Ï£ºÏ∞®**: Ìä∏ÎûúÏû≠ÏÖò Î°úÍπÖ Î∞è Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú

#### Phase 4: Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù (4-5Ï£º)
- **4Ï£ºÏ∞®**: ÏûêÎèô ÏùºÍ¥ÄÏÑ± Í≤ÄÏ¶ù ÏÑúÎπÑÏä§ Íµ¨ÌòÑ
- **5Ï£ºÏ∞®**: ÏûêÎèô ÏàòÏ†ï Í∏∞Îä• Î∞è ÏïåÎ¶º ÏãúÏä§ÌÖú

### 7.4 ÏÑ±Îä• Î™©Ìëú Î∞è ÏÑ±Í≥µ ÏßÄÌëú

**ÏÑ±Îä• Î™©Ìëú**:
- Í≤ÄÏÉâ ÏùëÎãµ ÏãúÍ∞Ñ: < 500ms (ÌòÑÏû¨ > 2s)
- Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÏßÄÏó∞: < 100ms
- Îç∞Ïù¥ÌÑ∞ ÏùºÍ¥ÄÏÑ±Î•†: > 95%
- ÏãúÏä§ÌÖú Í∞ÄÏö©ÏÑ±: > 99.9%

**ÏÑ±Í≥µ ÏßÄÌëú**:
1. UI ÏùëÎãµ ÏãúÍ∞Ñ 50% Í∞úÏÑ†
2. Îç∞Ïù¥ÌÑ∞ Ï§ëÎ≥µ Î¨∏Ï†ú 90% Ìï¥Í≤∞
3. Ïã§ÏãúÍ∞Ñ Îç∞Ïù¥ÌÑ∞ ÎèôÍ∏∞Ìôî 100% Íµ¨ÌòÑ
4. Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå®Ïú® < 0.1%

Ïù¥Îü¨Ìïú Íµ¨Ï≤¥Ï†ÅÏù∏ Íµ¨ÌòÑ Í≥ÑÌöçÏùÑ ÌÜµÌï¥ UI ÏóòÎ¶¨Î®ºÌä∏ÏôÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í∞ÑÏùò ÏôÑÏ†ÑÌïú Ïó∞ÎèôÏùÑ Íµ¨Ï∂ïÌïòÍ≥†, ÏïàÏ†ïÏ†ÅÏù¥Í≥† ÏÑ±Îä• Ï¢ãÏùÄ ÏãúÏä§ÌÖúÏùÑ Íµ¨ÌòÑÌï† Ïàò ÏûàÏäµÎãàÎã§.